
DOCUMENT START
TOKENS
/*********************
 * LEXICAL STRUCTURE *
 *********************/

/* WHITE SPACE */<DEFAULT,IN_STATEMENT_ANNOTATION,IN_IN_LINE_ANNOTATION> SKIP : {
" "
| "\t"
| "\f"
}

<DEFAULT> SKIP : {
"\n"
| "\r"
}

/* STATEMENT ANNOTATIONS */<DEFAULT> TOKEN : {
<SLASH_SLASH_AT: "//@"> : IN_STATEMENT_ANNOTATION
| <SLASH_STAR_AT: "/*@"> : IN_IN_LINE_ANNOTATION
}

<IN_STATEMENT_ANNOTATION> TOKEN : {
<EOL: ("//" (~["\n","\r"])*)? ("\n" | "\r" ("\n")?)> : DEFAULT
}

<IN_IN_LINE_ANNOTATION> SKIP : {
<("//" (~["\n","\r"])*)? ("\n" | "\r" ("\n")?)> : IN_DOCUMENTATION_COMMENT
}

/* COMMENTS */<DEFAULT> SKIP : {
<"/**" ~["/"]> : IN_DOCUMENTATION_COMMENT
}

<DEFAULT> MORE : {
"//" : IN_END_OF_LINE_COMMENT
| "/*" : IN_IN_LINE_COMMENT
}

<IN_END_OF_LINE_COMMENT> SKIP : {
<END_OF_LINE_COMMENT: "\n" | "\r" ("\n")?> : DEFAULT
}

<IN_END_OF_LINE_COMMENT> MORE : {
<~[]>
}

<IN_IN_LINE_COMMENT> MORE : {
<~["*"]>
| "*" : IN_IN_LINE_COMMENT_STAR
}

<IN_IN_LINE_COMMENT_STAR> MORE : {
<~["/"]> : IN_IN_LINE_COMMENT
}

<IN_IN_LINE_COMMENT_STAR> SKIP : {
<IN_LINE_COMMENT: "/"> : DEFAULT
}

<IN_DOCUMENTATION_COMMENT> MORE : {
<~["*"]>
| "*" : IN_DOCUMENTATION_COMMENT_STAR
}

<IN_DOCUMENTATION_COMMENT_STAR> TOKEN : {
<DOCUMENTATION_COMMENT: "/"> : DEFAULT
}

<IN_DOCUMENTATION_COMMENT_STAR> MORE : {
<~["/"]> : IN_DOCUMENTATION_COMMENT
}

/* RESERVED WORDS */<DEFAULT,IN_STATEMENT_ANNOTATION,IN_IN_LINE_ANNOTATION> TOKEN : {
<ABSTRACT: "abstract">
| <ACCEPT: "accept">
| <ACTIVE: "active">
| <ACTIVITY: "activity">
| <ALL_INSTANCES: "allInstances">
| <ANY: "any">
| <AS: "as">
| <ASSOC: "assoc">
| <BREAK: "break">
| <CASE: "case">
| <CLASS: "class">
| <CLASSIFY: "classify">
| <COMPOSE: "compose">
| <CREATE: "create">
| <DATATYPE: "datatype">
| <DEFAULT_: "default">
| <DESTROY: "destroy">
| <DO: "do">
| <ELSE: "else">
| <ENUM: "enum">
| <FOR: "for">
| <FROM: "from">
| <HASTYPE: "hastype">
| <IF: "if">
| <IMPORT: "import">
| <IN: "in">
| <INOUT: "inout">
| <INSTANCEOF: "instanceof">
| <LET: "let">
| <NAMESPACE: "namespace">
| <NEW: "new">
| <NONUNIQUE: "nonunique">
| <NULL: "null">
| <OR: "or">
| <ORDERED: "ordered">
| <OUT: "out">
| <PACKAGE: "package">
| <PRIVATE: "private">
| <PROTECTED: "protected">
| <PUBLIC: "public">
| <RECEIVE: "receive">
| <REDEFINES: "redefines">
| <RETURN: "return">
| <SPECIALIZES: "specializes">
| <SUPER: "super">
| <SIGNAL: "signal">
| <SWITCH: "switch">
| <THIS: "this">
| <TO: "to">
| <WHILE: "while">
| <COLLECTION_NAME: "Set" | "OrderedSet" | "Bag" | "Sequence" | "Option">
}

/* NAMES */<DEFAULT,IN_STATEMENT_ANNOTATION,IN_IN_LINE_ANNOTATION> TOKEN : {
<IDENTIFIER: <IDENTIFIER_LETTER> (<IDENTIFIER_LETTER_OR_DIGIT>)*>
| <#IDENTIFIER_LETTER_OR_DIGIT: <IDENTIFIER_LETTER> | <DIGIT>>
| <#IDENTIFIER_LETTER: ["a"-"z","A"-"Z","_"]>
| <#DIGIT: ["0"-"9"]>
| <UNRESTRICTED_NAME: "\'" (<NAME_CHARACTER>)+ "\'">
| <#NAME_CHARACTER: ~["\'","\\"] | <ESCAPE_CHARACTER>>
| <#ESCAPE_CHARACTER: "\\" <ESCAPED_CHARACTER>>
| <#ESCAPED_CHARACTER: ["\'","\"","b","f","n","\\"]>
}

/* PRIMITIVE LITERALS */<DEFAULT,IN_STATEMENT_ANNOTATION,IN_IN_LINE_ANNOTATION> TOKEN : {
<BOOLEAN_LITERAL: "true" | "false">
| <NATURAL_LITERAL: (<DIGIT>)+>
| <STRING_LITERAL: "\"" (<STRING_CHARACTER>)* "\"">
| <#STRING_CHARACTER: ~["\"","\\"]>
}

/* SEPARATORS */<DEFAULT,IN_STATEMENT_ANNOTATION,IN_IN_LINE_ANNOTATION> TOKEN : {
<LPAREN: "(">
| <RPAREN: ")">
| <LBRACE: "{">
| <RBRACE: "}">
| <LBRACKET: "[">
| <RBRACKET: "]">
| <SEMICOLON: ";">
| <COMMA: ",">
| <DOT: ".">
| <DOUBLE_DOT: "..">
| <COLON: ":">
| <DOUBLE_COLON: "::">
| <ARROW: "->">
| <THICK_ARROW: "=>">
}

/* OPERATORS */<DEFAULT,IN_STATEMENT_ANNOTATION,IN_IN_LINE_ANNOTATION> TOKEN : {
<ASSIGN: "=">
| <GT: ">">
| <LT: "<">
| <BANG: "!">
| <HOOK: "?">
| <AT: "@">
| <DOLLAR: "$">
| <EQ: "==">
| <LE: "<=">
| <GE: ">=">
| <NE: "!=">
| <SC_OR: "||">
| <SC_AND: "&&">
| <INCR: "++">
| <DECR: "--">
| <PLUS: "+">
| <MINUS: "-">
| <STAR: "*">
| <SLASH: "/">
| <LOGICAL_AND: "&">
| <LOGICAL_OR: "|">
| <XOR: "^">
| <REM: "%">
| <LSHIFT: "<<">
| <PLUSASSIGN: "+=">
| <MINUSASSIGN: "-=">
| <STARASSIGN: "*=">
| <SLASHASSIGN: "/=">
| <ANDASSIGN: "&=">
| <ORASSIGN: "|=">
| <XORASSIGN: "^=">
| <REMASSIGN: "%=">
| <HASH: "#">
| <DOUBLE_HASH: "##">
}

NON-TERMINALS
/************************
 * NAMES AND NAMESPACES *
 ************************/

/* QUALIFIED NAMES */	Name	:=	( <IDENTIFIER> | <UNRESTRICTED_NAME> )
	QualifiedName	:=	( ColonQualifiedName | DotQualifiedName | Name )
	NameOrColonQualifiedName	:=	( ColonQualifiedName | Name )
	ColonQualifiedName	:=	Name ( <DOUBLE_COLON> Name )+
	DotQualifiedName	:=	Name ( <DOT> Name )+
/* NAMESPACES */	NamespaceDefinition	:=	( PackageDefinition | ClassifierDefinition )
/* VISIBILITY */	VisibilityIndicator	:=	( ImportVisibilityIndicator | <PROTECTED> )
	ImportVisibilityIndicator	:=	( <PUBLIC> | <PRIVATE> )
/* UNITS */	UnitDefinition	:=	( NamespaceDeclaration )? ( ImportDeclaration )* ( <DOCUMENTATION_COMMENT> )? NamespaceDefinition <EOF>
	NamespaceDeclaration	:=	<NAMESPACE> QualifiedName <SEMICOLON>
	ImportDeclaration	:=	ImportVisibilityIndicator <IMPORT> ImportReference <SEMICOLON>
	ImportReference	:=	( ColonQualifiedName ( <DOUBLE_COLON> <STAR> | AliasDefinition )? | DotQualifiedName ( <DOT> <STAR> | AliasDefinition )? | Name ( ( <DOUBLE_COLON> | <DOT> ) <STAR> | AliasDefinition )? )
	AliasDefinition	:=	<AS> Name
/***********************
 * STRUCTURAL MODELING *
 ***********************/

/* PACKAGES */	PackageDeclaration	:=	<PACKAGE> Name
	PackageDefinition	:=	PackageDeclaration <LBRACE> ( PackagedElement )* <RBRACE>
	PackagedElement	:=	( <DOCUMENTATION_COMMENT> )? ImportVisibilityIndicator PackagedElementDefinition
	PackagedElementDefinition	:=	( NamespaceStubDeclaration | NamespaceDefinition )
	NamespaceStubDeclaration	:=	( PackageStubDeclaration | ClassifierStubDeclaration )
	PackageStubDeclaration	:=	PackageDeclaration <SEMICOLON>
/***************
 * CLASSIFIERS *
 ***************/	ClassifierDefinition	:=	( ClassDefinition | ActiveClassDefinition | DataTypeDefinition | EnumerationDefinition | AssociationDefinition | SignalDefinition | ActivityDefinition )
	ClassifierDeclaration	:=	( ClassDeclaration | ActiveClassDeclaration | DataTypeDeclaration | EnumerationDeclaration | AssociationDeclaration | SignalDeclaration | ActivityDeclaration )
	ClassifierStubDeclaration	:=	ClassifierDeclaration <SEMICOLON>
/* CLASSES */	ClassDeclaration	:=	( <ABSTRACT> )? <CLASS> Name ( SpecializationClause )?
	SpecializationClause	:=	<SPECIALIZES> QualifiedNameList
	QualifiedNameList	:=	QualifiedName ( <COMMA> QualifiedName )*
	ClassDefinition	:=	ClassDeclaration <LBRACE> ( ClassMember )* <RBRACE>
	ClassMember	:=	( <DOCUMENTATION_COMMENT> )? ( VisibilityIndicator )? ClassMemberDefinition
	ClassMemberDefinition	:=	( ClassifierStubDeclaration | ClassifierDefinition | FeatureStubDeclaration | FeatureDefinition )
/* ACTIVE CLASSES */	ActiveClassDeclaration	:=	( <ABSTRACT> )? <ACTIVE> <CLASS> Name ( SpecializationClause )?
	ActiveClassDefinition	:=	ActiveClassDeclaration <LBRACE> ( ActiveClassMember )* <RBRACE> ( <DO> BehaviorClause )?
	BehaviorClause	:=	( Block | Name )
	ActiveClassMember	:=	( <DOCUMENTATION_COMMENT> )? ( VisibilityIndicator )? ActiveClassMemberDefinition
	ActiveClassMemberDefinition	:=	( ClassMemberDefinition | ActiveFeatureDefinition | ActiveFeatureStubDeclaration )
/* DATA TYPES */	DataTypeDeclaration	:=	( <ABSTRACT> )? <DATATYPE> Name ( SpecializationClause )?
	DataTypeDefinition	:=	DataTypeDeclaration StructuredBody
	StructuredBody	:=	<LBRACE> ( StructuredMember )* <RBRACE>
	StructuredMember	:=	( <DOCUMENTATION_COMMENT> )? ( <PUBLIC> )? PropertyDefinition
/* ASSOCIATIONS */	AssociationDeclaration	:=	( <ABSTRACT> )? <ASSOC> Name ( SpecializationClause )?
	AssociationDefinition	:=	AssociationDeclaration StructuredBody
/* ENUMERATIONS */	EnumerationDeclaration	:=	<ENUM> Name ( SpecializationClause )?
	EnumerationDefinition	:=	EnumerationDeclaration <LBRACE> EnumerationLiteralName ( <COMMA> EnumerationLiteralName )* <RBRACE>
	EnumerationLiteralName	:=	( <DOCUMENTATION_COMMENT> )? Name
/* SIGNALS */	SignalDeclaration	:=	( <ABSTRACT> )? <SIGNAL> Name ( SpecializationClause )?
	SignalDefinition	:=	SignalDeclaration StructuredBody
/* FEATURES */	FeatureDefinition	:=	( AttributeDefinition | OperationDefinition | ConstructorDefinition | DestructorDefinition )
	FeatureStubDeclaration	:=	( OperationStubDeclaration | ConstructorStubDeclaration | DestructorStubDeclaration )
	ActiveFeatureDefinition	:=	( ReceptionDefinition | SignalReceptionDefinition )
	ActiveFeatureStubDeclaration	:=	SignalReceptionStubDeclaration
/* PROPERTIES */	PropertyDefinition	:=	PropertyDeclaration <SEMICOLON>
	AttributeDefinition	:=	PropertyDeclaration ( AttributeInitializer )? <SEMICOLON>
	AttributeInitializer	:=	<ASSIGN> Expression
	PropertyDeclaration	:=	Name <COLON> ( <COMPOSE> )? TypePart
	TypePart	:=	TypeName ( Multiplicity )?
		|	<COLLECTION_NAME> ( <LT> TypeName <GT> )?
	TypeName	:=	( QualifiedName | <ANY> )
	Multiplicity	:=	<LBRACKET> ( MultiplicityRange )? <RBRACKET> ( <ORDERED> )? ( <NONUNIQUE> )?
	MultiplicityRange	:=	( <NATURAL_LITERAL> <DOUBLE_DOT> )? UnlimitedNaturalLiteral
	UnlimitedNaturalLiteral	:=	( <NATURAL_LITERAL> | <STAR> )
/* OPERATIONS */	OperationDeclaration	:=	( <ABSTRACT> )? Name FormalParameters ( <COLON> TypePart )? ( RedefinitionClause )?
	OperationDefinition	:=	OperationDeclaration Block
	OperationStubDeclaration	:=	OperationDeclaration <SEMICOLON>
	FormalParameters	:=	<LPAREN> ( FormalParameterList )? <RPAREN>
	FormalParameterList	:=	FormalParameter ( <COMMA> FormalParameter )*
	FormalParameter	:=	( <DOCUMENTATION_COMMENT> )? ParameterDirection Name <COLON> TypePart
	ParameterDirection	:=	( <IN> | <OUT> | <INOUT> )
	RedefinitionClause	:=	<REDEFINES> QualifiedNameList
/* CONSTRUCTORS */	ConstructorDeclaration	:=	<CREATE> Name FormalParameters
	ConstructorDefinition	:=	ConstructorDeclaration ConstructorBody
	ConstructorStubDeclaration	:=	ConstructorDeclaration <SEMICOLON>
	ConstructorBody	:=	<LBRACE> ( ExplicitConstructorInvocations )? BlockCompletion
	ExplicitConstructorInvocations	:=	( AlternativeConstructorInvocation | ( SuperclassConstructorInvocation )+ )
	AlternativeConstructorInvocation	:=	( <DOCUMENTATION_COMMENT> )? <THIS> ( <DOT> Name )? Tuple <SEMICOLON>
	SuperclassConstructorInvocation	:=	( <DOCUMENTATION_COMMENT> )? <SUPER> ( <DOT> QualifiedName )? Tuple <SEMICOLON>
/* DESTRUCTORS */	DestructorDeclaration	:=	<DESTROY> Name FormalParameters
	DestructorDefinition	:=	DestructorDeclaration Block
	DestructorStubDeclaration	:=	DestructorDeclaration <SEMICOLON>
/* RECEPTIONS */	ReceptionDefinition	:=	<RECEIVE> QualifiedName <SEMICOLON>
	SignalReceptionDeclaration	:=	<RECEIVE> <SIGNAL> Name ( SpecializationClause )?
	SignalReceptionDefinition	:=	SignalReceptionDeclaration StructuredBody
	SignalReceptionStubDeclaration	:=	SignalReceptionDeclaration <SEMICOLON>
/***********************
 * BEHAVIORAL MODELING *
 ***********************/

/* ACTIVITIES */	ActivityDeclaration	:=	<ACTIVITY> Name FormalParameters ( <COLON> TypePart )?
	ActivityDefinition	:=	ActivityDeclaration Block
/* BLOCK */	Block	:=	<LBRACE> BlockCompletion
	BlockCompletion	:=	( DocumentedStatement )* <RBRACE>
	DocumentedStatement	:=	( <DOCUMENTATION_COMMENT> )? Statement
/* STATEMENTS */	Statement	:=	( AnnotatedStatement | InLineStatement | BlockStatement | EmptyStatement | LocalNameDeclarationOrExpressionStatement | LocalNameDeclarationStatement | IfStatement | SwitchStatement | WhileStatement | ForStatement | DoStatement | BreakStatement | ReturnStatement | AcceptStatement | ClassifyStatement )
/* ANNOTATED STATEMENTS */	AnnotatedStatement	:=	<SLASH_SLASH_AT> Annotations <EOL> Statement
	Annotations	:=	Annotation ( <AT> Annotation )*
	Annotation	:=	<IDENTIFIER> ( <LPAREN> NameList <RPAREN> )?
	NameList	:=	Name ( <COMMA> Name )*
/* IN-LINE STATEMENTS */	InLineStatement	:=	<SLASH_STAR_AT> <IDENTIFIER> <LPAREN> Name <RPAREN> <DOCUMENTATION_COMMENT>
/* BLOCK STATEMENTS */	BlockStatement	:=	Block
/* EMPTY STATEMENTS */	EmptyStatement	:=	<SEMICOLON>
/* LOCAL NAME DECLARATION AND EXPRESSION STATEMENTS */	LocalNameDeclarationOrExpressionStatement	:=	( ColonQualifiedName ( ( MultiplicityIndicator )? Name LocalNameDeclarationStatementCompletion | UnambiguousQualifiedNameExpressionCompletion <SEMICOLON> ) | DotQualifiedName ( ( MultiplicityIndicator )? Name LocalNameDeclarationStatementCompletion | AmbiguousQualifiedNameExpressionCompletion <SEMICOLON> ) | Name ( ( MultiplicityIndicator )? Name LocalNameDeclarationStatementCompletion | NameExpressionCompletion <SEMICOLON> ) | NonNameExpression <SEMICOLON> )
	MultiplicityIndicator	:=	<LBRACKET> <RBRACKET>
	LocalNameDeclarationStatement	:=	<LET> Name <COLON> TypeName ( MultiplicityIndicator )? LocalNameDeclarationStatementCompletion
	LocalNameDeclarationStatementCompletion	:=	<ASSIGN> Expression <SEMICOLON>
/* IF STATEMENTS */	IfStatement	:=	<IF> SequentialClauses ( FinalClause )?
	SequentialClauses	:=	ConcurrentClauses ( <ELSE> <IF> ConcurrentClauses )*
	ConcurrentClauses	:=	NonFinalClause ( <OR> <IF> NonFinalClause )*
	NonFinalClause	:=	<LPAREN> Expression <RPAREN> Block
	FinalClause	:=	<ELSE> Block
/* SWITCH STATEMENTS */	SwitchStatement	:=	<SWITCH> <LPAREN> Expression <RPAREN> <LBRACE> ( SwitchClause )* ( SwitchDefaultClause )? <RBRACE>
	SwitchClause	:=	SwitchCase ( SwitchCase )* Block
	SwitchCase	:=	<CASE> Expression <COLON>
	SwitchDefaultClause	:=	<DEFAULT_> <COLON> Block
/* WHILE STATEMENTS */	WhileStatement	:=	<WHILE> <LPAREN> Expression <RPAREN> Block
/* DO STATEMENTS */	DoStatement	:=	<DO> Block <WHILE> <LPAREN> Expression <RPAREN> <SEMICOLON>
/* FOR STATEMENTS */	ForStatement	:=	<FOR> <LPAREN> ForControl <RPAREN> Block
	ForControl	:=	ForVariableDefinition ( <COMMA> ForVariableDefinition )* ( <WHILE> Expression )?
	ForVariableDefinition	:=	Name <IN> Expression ( <DOUBLE_DOT> Expression )?
/* BREAK STATEMENTS */	BreakStatement	:=	<BREAK> <SEMICOLON>
/* RETURN STATEMENTS */	ReturnStatement	:=	<RETURN> Expression <SEMICOLON>
/* ACCEPT STATEMENTS */	AcceptStatement	:=	AcceptClause ( SimpleAcceptStatementCompletion | CompoundAcceptStatementCompletion )
	SimpleAcceptStatementCompletion	:=	<SEMICOLON>
	CompoundAcceptStatementCompletion	:=	Block ( <OR> AcceptBlock )*
	AcceptBlock	:=	AcceptClause Block
	AcceptClause	:=	<ACCEPT> <LPAREN> ( Name <COLON> )? QualifiedNameList <RPAREN>
/* CLASSIFY STATEMENTS */	ClassifyStatement	:=	<CLASSIFY> Expression ClassificationClause <SEMICOLON>
	ClassificationClause	:=	ClassificationFromClause ( ClassificationToClause )?
		|	( ReclassifyAllClause )? ClassificationToClause
	ClassificationFromClause	:=	<FROM> QualifiedNameList
	ClassificationToClause	:=	<TO> QualifiedNameList
	ReclassifyAllClause	:=	<FROM> <STAR>
/***************
 * EXPRESSIONS *
 ***************/	Expression	:=	( ColonQualifiedName UnambiguousQualifiedNameExpressionCompletion | DotQualifiedName AmbiguousQualifiedNameExpressionCompletion | Name NameExpressionCompletion | NonNameExpression )
	NonNameExpression	:=	( NonPostfixUnaryExpression ConditionalExpressionCompletion | BaseExpression ExpressionCompletion )
	ExpressionCompletion	:=	( Index ExpressionCompletion | NonIndexExpressionCompletion )
	NonIndexExpressionCompletion	:=	( Feature FeatureExpressionCompletion | NonFeatureExpressionCompletion )
	NonFeatureExpressionCompletion	:=	( DestroyInvocation ExpressionCompletion | CollectionOperation ExpressionCompletion | CollectionExpansion ExpressionCompletion | PostfixOperation ConditionalExpressionCompletion )
	UnambiguousQualifiedNameExpressionCompletion	:=	( Assignment | CollectionExpressionCompletion ExpressionCompletion | ExpressionCompletion )
	AmbiguousQualifiedNameExpressionCompletion	:=	( Assignment | CollectionExpressionCompletion ExpressionCompletion | Index IndexFeatureExpressionCompletion | NonIndexExpressionCompletion )
	NameExpressionCompletion	:=	( Assignment | CollectionExpressionCompletion ExpressionCompletion | Index ExpressionCompletion | NonFeatureExpressionCompletion )
	FeatureExpressionCompletion	:=	( Assignment | Index IndexFeatureExpressionCompletion | FeatureInvocation ExpressionCompletion | NonIndexExpressionCompletion )
	IndexFeatureExpressionCompletion	:=	( Assignment | Index ExpressionCompletion | NonIndexExpressionCompletion )
/* PRIMARY EXPRESSIONS */	BaseExpression	:=	( LiteralExpression | ThisExpression | ParenthesizedExpression | SuperInvocationOrDestroyExpression | InstanceCreationOrCollectionValueExpression | ReductionExpression | CollectionAnyExpression )
/* LITERAL EXPRESSIONS */	LiteralExpression	:=	( <BOOLEAN_LITERAL> | <NATURAL_LITERAL> | <STRING_LITERAL> | <STAR> )
/* NAME EXPRESSIONS */	NameOrCollectionExpression	:=	( ColonQualifiedName | DotQualifiedName | Name ) ( CollectionExpressionCompletion )?
/* THIS EXPRESSIONS */	ThisExpression	:=	<THIS>
/* PARENTHESIZED EXPRESSIONS */	ParenthesizedExpression	:=	<LPAREN> Expression <RPAREN>
/* PROPERTY ACCESS EXPRESSIONS */	Feature	:=	<DOT> Name
/* INVOCATION EXPRESSIONS */	Tuple	:=	( NamedTuple | PositionalTuple )
	PositionalTuple	:=	<LPAREN> ( ExpressionList )? <RPAREN>
	ExpressionList	:=	Expression ( <COMMA> Expression )*
	NamedTuple	:=	<LPAREN> NamedExpression ( <COMMA> NamedExpression )* <RPAREN>
	NamedExpression	:=	Name <THICK_ARROW> Expression
	BehaviorInvocation	:=	Tuple
	FeatureInvocation	:=	Tuple
	SuperInvocationOrDestroyExpression	:=	<SUPER> <DOT> ( SuperInvocation | SuperDestroyInvocation )
	SuperInvocation	:=	QualifiedName Tuple
/* INSTANCE CREATION EXPRESSIONS */	InstanceCreationOrCollectionValueExpression	:=	<NEW> QualifiedName ( CollectionValueExpressionCompletion | Tuple )
/* INSTANCE DESTRUCTION EXPRESSIONS */	DestroyInvocation	:=	<DOT> <DESTROY> Tuple
	SuperDestroyInvocation	:=	<DESTROY> Tuple
/* REDUCTION EXPRESSIONS */	ReductionExpression	:=	ReductionOperator QualifiedName <LPAREN> Expression <RPAREN>
	ReductionOperator	:=	( <HASH> | <DOUBLE_HASH> )
/* COLLECTION EXPRESSIONS */	CollectionExpression	:=	BaseCollectionExpression ( CollectionModifier )*
	BaseCollectionExpression	:=	( NameOrCollectionExpression | BaseExpression )
	CollectionExpressionCompletion	:=	( ClassExtentExpressionCompletion | CollectionValueExpressionCompletion | BehaviorInvocation )
	CollectionModifier	:=	( DestroyInvocation | Feature ( FeatureInvocation )? | CollectionOperation | CollectionExpansion | Index )
/* CLASS EXTENT EXPRESSIONS */	ClassExtentExpressionCompletion	:=	<DOT> <ALL_INSTANCES> <LPAREN> <RPAREN>
/* COLLECTION VALUE EXPRESSIONS */	CollectionAnyExpression	:=	( <ANY> CollectionValueExpressionCompletion | <NULL> )
	CollectionValueExpressionCompletion	:=	MultiplicityIndicator <LBRACE> ( CollectionElements )? <RBRACE>
	CollectionElements	:=	Expression ( <DOUBLE_DOT> Expression | ( <COMMA> Expression )* )
/* COLLECTION ACCESS EXPRESSIONS */	Index	:=	<LBRACKET> Expression <RBRACKET>
/* COLLECTION OPERATION EXPRESSIONS */	CollectionOperation	:=	<ARROW> <IDENTIFIER> CollectionOperationTuple
	CollectionOperationTuple	:=	( IndexedNamedTuple | PositionalTuple )
	IndexedNamedTuple	:=	<LPAREN> IndexedNamedExpression ( <COMMA> IndexedNamedExpression )* <RPAREN>
	IndexedNamedExpression	:=	Name ( Index )? <THICK_ARROW> Expression
/* COLLECTION EXPANSION EXPRESSIONS */	CollectionExpansion	:=	<ARROW> <IDENTIFIER> Name Tuple
/* POSTFIX EXPRESSIONS */	PostfixExpression	:=	CollectionExpression PostfixOperation
	PostfixOperation	:=	( AffixOperator )*
	AffixOperator	:=	( <INCR> | <DECR> )
/* UNARY EXPRESSIONS */	UnaryExpression	:=	( PrefixedExpression | NumericUnaryExpression | NonNumericUnaryExpression )
	NonNumericUnaryExpression	:=	( CastExpression | PostfixExpression | BooleanNegationExpression | IsolationExpression )
	CastLookahead	:=	<LPAREN> TypeName <RPAREN> ( <BANG> | <DOLLAR> | <LPAREN> | <NEW> | TypeName | LiteralExpression | ThisExpression | ReductionOperator )
	NonPostfixUnaryExpression	:=	( PrefixedExpression | NumericUnaryExpression | CastExpression | BooleanNegationExpression | IsolationExpression )
	PrefixedExpression	:=	AffixOperator UnaryExpression
	BooleanNegationExpression	:=	<BANG> UnaryExpression
	NumericUnaryExpression	:=	NumericUnaryOperator UnaryExpression
	NumericUnaryOperator	:=	( <PLUS> | <MINUS> )
	IsolationExpression	:=	<DOLLAR> UnaryExpression
	CastExpression	:=	<LPAREN> TypeName <RPAREN> NonNumericUnaryExpression
/* MULTIPLICATIVE OPERATORS */	MultiplicativeExpression	:=	UnaryExpression MultiplicativeExpressionCompletion
/* ADDED */	MultiplicativeExpressionCompletion	:=	( MultiplicativeOperator UnaryExpression )*
	MultiplicativeOperator	:=	( <STAR> | <SLASH> | <REM> )
/* ADDITIVE OPERATORS */	AdditiveExpression	:=	UnaryExpression AdditiveExpressionCompletion
	AdditiveExpressionCompletion	:=	MultiplicativeExpressionCompletion ( AdditiveOperator MultiplicativeExpression )*
	AdditiveOperator	:=	( <PLUS> | <MINUS> )
/* RELATIONAL OPERATORS */	RelationalExpression	:=	UnaryExpression RelationalExpressionCompletion
	RelationalExpressionCompletion	:=	AdditiveExpressionCompletion ( RelationalOperator AdditiveExpression )*
	RelationalOperator	:=	( <LT> | <GT> | <LE> | <GE> )
	ClassificationExpression	:=	UnaryExpression ClassificationExpressionCompletion
	ClassificationExpressionCompletion	:=	RelationalExpressionCompletion ( ClassificationOperator QualifiedName )?
	ClassificationOperator	:=	( <INSTANCEOF> | <HASTYPE> )
/* EQUALITY OPERATORS */	EqualityExpression	:=	UnaryExpression ClassificationExpressionCompletion
	EqualityExpressionCompletion	:=	ClassificationExpressionCompletion ( EqualityOperator ClassificationExpression )*
	EqualityOperator	:=	( <EQ> | <NE> )
/* LOGICAL OPERATORS */	AndExpression	:=	UnaryExpression AndExpressionCompletion
	AndExpressionCompletion	:=	EqualityExpressionCompletion ( <LOGICAL_AND> EqualityExpression )*
	ExclusiveOrExpression	:=	UnaryExpression ExclusiveOrExpressionCompletion
	ExclusiveOrExpressionCompletion	:=	AndExpressionCompletion ( <XOR> AndExpression )*
	InclusiveOrExpression	:=	UnaryExpression InclusiveOrExpressionCompletion
	InclusiveOrExpressionCompletion	:=	ExclusiveOrExpressionCompletion ( <LOGICAL_OR> ExclusiveOrExpression )*
/* CONDITIONAL-AND OPERATOR */	ConditionalAndExpression	:=	UnaryExpression ConditionalAndExpressionCompletion
	ConditionalAndExpressionCompletion	:=	InclusiveOrExpressionCompletion ( <SC_AND> InclusiveOrExpression )*
/* CONDITIONAL-OR OPERATOR */	ConditionalOrExpression	:=	UnaryExpression ConditionalOrExpressionCompletion
	ConditionalOrExpressionCompletion	:=	ConditionalAndExpressionCompletion ( <SC_OR> ConditionalAndExpression )*
/* CONDITIONAL-TEST OPERATOR */	ConditionalExpression	:=	UnaryExpression ConditionalExpressionCompletion
	ConditionalExpressionCompletion	:=	ConditionalOrExpressionCompletion ( <HOOK> Expression <COLON> ConditionalExpression )?
/* ASSIGNMENT OPERATORS */	Assignment	:=	AssignmentOperator Expression
	AssignmentOperator	:=	( <ASSIGN> | <PLUSASSIGN> | <MINUSASSIGN> | <STARASSIGN> | <SLASHASSIGN> | <REMASSIGN> | <ANDASSIGN> | <ORASSIGN> | <XORASSIGN> )

DOCUMENT END
