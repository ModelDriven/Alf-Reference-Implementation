arithmeticExpressionOperandMultiplicity
Multiplicity upper bounds of both operands must be 1.
The operand expressions of an arithmetic expressions must both have multiplicity upper bounds of 1.

arithmeticExpressionOperandTypes
Illegal operand types.
The operands of an arithmetic expression must both have a type that conforms to type Integer or Real, unless the operator is + or %. If the operator is +, then both operands may also both have type a type that conforms to String. If the operator is %, then both operands must have a type that conforms to type Integer. 

assignmentExpressionAssignmentsBefore

The assigned source of a name before the right-hand side expression of an assignment expression is the same as the assigned source before the assignment expression. The assigned source of a name before the left-hand side is the assigned source after the right-hand side expression.

assignmentExpressionCompoundAssignmentMultiplicityConformance
Multiplicity upper bound must be 1.
For a compound assignment, both the left-hand and right-hand sides must have a multiplicity upper bound of 1.
 
assignmentExpressionCompoundAssignmentTypeConformance
Illegal types for the operator used.
For a compound assignment, if the operator is an arithmetic operator, then either the left-hand side and the right-hand side both have a type that conforms to type Integer, the left-hand side has a type that conforms to type Real and the right-hand side has a type that conforms to type Integer or Real, or they both have a type that conforms to type String and the operator is +. If the operator is a logical operator, then either the left-hand side and the right-hand side both have a type that conforms to type Boolean or Bit String or the left-hand side has type Bit String and the right-hand side has a type that conforms to type Integer. If the operator is a shift operator, then the left-hand side must have a type that conforms to type Bit String and the right-hand side must have a type that conforms to type Integer.
 
assignmentExpressionDataValueUpdateLegality
Illegal data value update.
If an assignment expression has a feature with a primary expression whose type is a data type, then the assignment expression must be a data value update.
 
assignmentExpressionSimpleAssignmentMultiplicityConformance
Multiplicities must conform.
If the left-hand side of a simple assignment is not a local name and the multiplicity lower bound of the left-hand side is greater than 0, then the multiplicity lower bound of the right-hand side cannot be 0. If the left-hand side is not a new local name and the multiplicity upper bound of the left-hand side is less than or equal to 1, then the multiplicity upper bound of the right-hand side cannot be greater than that of the left-hand side.
 
assignmentExpressionSimpleAssignmentTypeConformance
Right-hand side must have a type that conforms to the type of the left-hand side.
If the left-hand side of a simple assignment is not a new local name, and the right-hand side is not null, then either the left-hand side must be untyped or the right-hand side expression must have a type that conforms to the type of the left-hand side.
 
behaviorInvocationExpressionAlternativeConstructor
Constructor invocation not allowed here.
The referent may only be a constructor (as a result of the target disambiguating to a feature reference) if this behavior invocation expression is the expression of an expression statement that is the first statement in the definition for the method of a constructor operation.
 
behaviorInvocationExpressionArgumentCompatibility
One or more arguments are not compatible (in type and/or multiplicity) with the behavior parameters.
If the target qualified name does not disambiguate to a feature reference, then each input argument expression must be assignable to its corresponding parameter and each output argument expression must be assignable from its corresponding parameter. (Note that this implies that the type of an argument expression for an inout parameter must be the same as the type of that parameter.)
 
behaviorInvocationExpressionReferentConstraint
Behavior or feature reference cannot be resolved or arguments are not compatible (in type and/or multiplicity) with corresponding parameters.
If the target qualified name does not disambiguate to a feature reference, then it must resolve to a behavior or an association end. Otherwise it must resolve to a single feature referent according to the overloading resolution rules, unless it is an implicit destructor call (in which case it has no referent).
 
binaryExpressionOperandAssignments
Invalid assignments in expression operands.
The assignments in the operand expressions of a binary expression must be valid (as determined by the validateAssignments helper operation).
 
binaryExpressionOperandMultiplicity
One or both operands have illegal multiplicity.
The operands of a binary expression must both have a multiplicity lower bound no less than that given by the minLowerBound helper operation. The operands of a binary expression must both have a multiplicity upper bound no greater than that given by the maxUpperBound helper operation.
 
bitStringUnaryExpressionOperand
Operand must have type BitString or Integer and multiplicity 1..1.
The operand expression of a BitString unary expression must have a type that conforms to type BitString or Integer and multiplicity lower and upper bounds of 1.
 
booleanUnaryExpressionOperand
Operand must have type Boolean and multiplicity upper bound of 1.
The operand expression of a Boolean unary expression must have a type that conforms to type Boolean and a multiplicity upper bound of 1.
 
castExpressionAssignmentsBefore

The assignments before the operand of a cast expression are the same as those before the cast expression.
 
castExpressionTypeResolution
Type name must resolve to a non-template classifier.
If the cast expression has a type name, then it must resolve to a non-template classifier.
 
classExtentExpressionExtentType
Type name must resolve to a non-template class.
The given type name must resolve to a non-template class.
 
classificationExpressionOperand
Operand multiplicity must be 1..1.
The operand expression of a classification expression must have multiplicity lower and upper bounds of 1.
 
classificationExpressionTypeName
Type name must resolve to a non-template classifier.
The type name in a classification expression must resolve to a non-template classifier.
 
conditionalLogicalExpressionOperands
Operands must have type Boolean.
The operands of a conditional logical expression must have a type that conforms to type Boolean.
 
conditionalTestExpressionAssignmentsBefore

The assignments before the first operand expression of a conditional-test expression are the same as those before the conditional-test expression. The assignments before the second and third operand expressions are the same as those after the first operand expression.
 
conditionalTestExpressionCondition
First operand must have type Boolean and multiplicity 1..1.
The first operand expression of a conditional-test expression must be of a type that conforms to type Boolean and multiplicity lower and upper bounds of 1.
 
expressionUniqueAssignments

No name may be assigned more than once before or after an expression.
 
featureInvocationExpressionAlternativeConstructor
Alternative constructor invocation not allowed here.
An alternative constructor invocation may only occur in an expression statement as the first statement in the definition for the method of a constructor operation.
 
featureInvocationExpressionImplicitAlternativeConstructor
Target type must have a constructor with the same name.
If there is no target feature expression, then the implicit feature with the same name as the target type must be a constructor.
 
featureInvocationExpressionReferentExists
Feature reference cannot be resolved or arguments are not compatible (in type and/or multiplicity) with corresponding parameters.
If a feature invocation expression is not an implicit destructor call, then it must be possible to determine a single valid referent for it according to the overloading resolution rules.
 
featureLeftHandSideAssignmentsBefore

If a feature left-hand side has an index, then the assignments before the index expression are the assignments after the expression of the feature reference.
 
featureLeftHandSideFeatureExpression
Target expression must have a multiplicity upper bound of 1.
The expression of the feature reference of a feature left-hand side must have a multiplicity upper bound of 1.
 
featureLeftHandSideIndexedFeature
Referenced feature must be ordered and non-unique.
If a feature left-hand side has an index, then the referent of the feature must be ordered and non-unique.
 
featureLeftHandSideReferentConstraint
Referenced feature must be a property.
The feature of a feature-left hand side must have a single referent that is a structural feature.
 
featureReferenceTargetType
Type of the target expression must be a class or a structured data type.
The target expression of the feature reference may not be untyped, nor may it have a primitive or enumeration type.
 
forAllOrExistsOrOneExpressionArgument
Argument must have type Boolean and multiplicity upper bound of 1.
The argument of a forAll, exists or one expression must have a type that conforms to type Boolean and a multiplicity upper bound of 1.
 
incrementOrDecrementExpressionAssignmentsBefore

The assignments before the operand of an increment or decrement expression are the same as those before the increment or decrement expression.
 
incrementOrDecrementExpressionOperand
Operand must have a type Integer or Real and multiplicity upper bound of 1.
The operand expression must have a type that conforms to type Integer or Real and a multiplicity upper bound of 1.
 
instanceCreationExpressionConstructor
Constructor name must resolve to a compatible constructor operation, class or data type.
The constructor name must resolve to a constructor operation (that is compatible with the tuple argument expressions), a class or a data type, but not both a class and a data type.
 
instanceCreationExpressionConstructorlessLegality
No matching constructor found.
If the expression is constructorless, then its tuple must be empty and the referent class must not have any owned operations that are constructors.

instanceCreationExpressionDataTypeCompatibility
One or more arguments are not compatible with data type attributes.
If an instance creation expression is a data value creation (not an object creation), then the tuple argument expressions are matched with the attributes of the named type.
 
instanceCreationExpressionReferent
Instantiated type must be a non-abstract class or data type.
If the referent of an instance creation expression is an operation, then the class of that operation must not be abstract. Otherwise, the referent is a class or data type, which must not be abstract.
 
invocationExpressionAssignmentsBefore

The assignments before the target expression of the feature reference of an invocation expression (if any) are the same as the assignments before the invocation expression.
 
invocationExpressionTemplateParameters
Only classifier template parameters allowed for an implicit template instantiation.
If the referent of the invocation expression is a template, then all of its template parameters must be classifier template parameters. Note: This allows for the possibility that the referent is not an Alf unit, in which case it could have non-classifier template parameters.

invocationExpressionAssignmentsAfter
Assignments not allowed in tuple of sequence feature invocation.
If invocation is a sequence feature invocation, then the assignments after the tuple of the invocation expression must be the same as the assignments before.

invocationExpressionReferent
Feature reference cannot be resolved or arguments are not compatible (in type and/or multiplicity) with corresponding parameters.
The referent of an invocation cannot be a signal unless it is a signal reception.

isUniqueExpressionExpressionArgument
Argument must have a multiplicity upper bound of 1.
The argument of an isUnique expression must have a multiplicity upper bound of 1.

leftHandSideDataValueUpdateLegality
Illegal data value update.
If a left-hand side is for a feature reference whose expression is a data type, then it must be a legal data value update.
 
leftHandSideIndexExpression
Index expression must have a multiplicity upper bound no greater than 1.
If a left-hand side has an index, then the index expression must have a multiplicity upper bound no greater than 1.
 
linkOperationExpressionArgumentCompatibility
One or more arguments are not compatible (in type and/or multipicity) with corresponding association ends.
Each argument expression must be assignable to its corresponding association end.
 
linkOperationExpressionAssociationReference
Association name cannot be resolved.
The qualified name of a link operation expression must resolve to a single association.
 
logicalExpressionOperands
Operands must either both have type Boolean or have type Integer or BitString.
The operands of a logical expression must have type Boolean, Integer or BitString. However, if one of the operands is Boolean, then the other must also be Boolean.
 
namedTupleArgumentNames
Argument names must be parameter names, without repetition.
The name of a named expression of a named tuple must be the name of a parameter of the invocation the tuple is for. No two named expressions may have the same name.
 
nameExpressionResolution
Name cannot be resolved (or has not been assigned).
If the name referenced by this expression is not a disambiguated feature reference or a local or parameter name, then it must resolve to exactly one enumeration literal.
 
nameLeftHandSideAssignmentsBefore

If the target of a name left-hand side disambiguates to a feature reference, then the assignments before the expression of the feature reference are the assignments before the left-hand side. If a name left-hand side has an index, then the target must either disambiguate to a feature reference or already have an assigned source, and the assignments before the index expression are the assignments before the left-hand side or, if the target disambiguates to a feature reference, the assignments after the expression of the feature reference.
 
nameLeftHandSideIndexedFeature
Referenced feature must be ordered and non-unique.
If the target of a name left-hand side disambiguates to a feature reference, and the left-hand side has an index, then the referent of the feature reference must be ordered and non-unique.
 
nameLeftHandSideNontemplateTarget
Target must not have a template binding.
The target of a name left-hand side must not have a template binding.
 
nameLeftHandSideTargetAssignment
Target cannot be reassigned.
The target of a name left hand side may not already have an assigned source that is a loop variable definition, an annotation, a sequence expansion expression or a parameter that is an in parameter.
 
nameLeftHandSideTargetResolution
Target cannot be resolved or resolves to a feature that is not a property.
If the target of a name left-hand side is qualified, then, if it does not disambiguate to a feature, it must have a referent that is a parameter of an operation or behavior that is the current scope the left-hand is in, and, if it does disambiguate to a feature, it must have a single referent that is a structural feature.

nameLeftHandSideFeatureExpression
Target expression must have a multiplicity upper bound of 1.
If the target of a name left-hand side disambiguates to a feature reference, then the expression of the feature reference must have a multiplicity upper bound of 1.

nullCoalescingExpressionAssignmentsBefore

The assignments before the first operand expression of a null-coalescing expression are the same as those before the null-coalescing expression. The assignments before the second operand expression are the same as those after the first operand expression.
 
numericUnaryExpressionOperand
Operand must have a type Integer or Real and multiplicity upper bound of 1.
The operand expression must have a type that conforms to type Integer or Real and a multiplicity upper bound of 1.
 
outputNamedExpressionForm
Illegal for output named expression.
The argument for an output parameter must be either be null, a name expression, a property access expression, or a sequence access expression whose primary expression is a name expression or a property access expression.
 
positionalTupleArguments
Too many arguments.
A positional tuple must not have more arguments than the invocation it is for has parameters.
 
propertyAccessExpressionAssignmentsBefore

The assignments before the expression of the feature reference of a property access expression are the same as before the property access expression.
 
propertyAccessExpressionFeatureResolution
Referenced feature must resolve to a property.
The feature reference for a property access expression must resolve to a single structural feature.
 
qualifiedNameLocalName
Local name out of scope.
If a qualified name is a local name, then the reference must be within the same local scope as the definition of the named element.
 
qualifiedNameNonLocalUnqualifiedName
Name not visible.
If a qualified name is an unqualified, non-local name, then it must be visible in the current scope of the use of the name.
 
qualifiedNameQualifiedResolution
Qualified name cannot be resolved.
If a qualified name has a qualification, then its unqualified name must name an element of the namespace named by the qualification, where the first name in the qualification must name an element of the current scope.
 
qualifiedNameTemplateBinding
Name must resolved to a template and arguments must be compatible with template parameters.
If the unqualified name of a qualified name has a template binding, then the template name must resolve to a template. The template binding must have an argument name for each of the template parameters and each argument name must resolve to a classifier. If the template parameter has constraining classifiers, then the referent of the corresponding argument name must conform to all those constraining classifiers.
 
relationalExpressionOperandTypes
Operands must either both have type Natural, Integer or Real, or both have type Natural or UnlimitedNatural.
The operand expressions for a comparison operator must both be of a type that conforms to type Natural, Integer or Real, or both be of a type that conforms to type Natural or UnlimitedNatural.
 
selectOrRejectExpressionArgument
Argument must have type Boolean and multiplicity upper bound of 1.
The argument of a select or reject expression must have a type that conforms to type Boolean and a multiplicity upper bound of 1.
 
sequenceAccessExpressionIndexMultiplicity
Index expression multiplicity upper bound must be 1.
The multiplicity upper bound of the index of a sequence access expression must be 1.
 
sequenceAccessExpressionIndexType
Index expression type must be Integer.
The type of the index of a sequence access expression must be Integer.
 
sequenceConstructionExpressionAssignmentsBefore

If the elements of a sequence construction expression are given by a sequence expression list, then the assignments before the first expression in the list are the same as the assignments before the sequence construction expression, and the assignments before each subsequent expression are the assignments after the previous expression. If the elements are given by a sequence range, the assignments before both expressions in the range are the same as the assignments before the sequence construction expression.
 
sequenceConstructionExpressionElementType
Element types not compatible with the expression type.
If the elements of a sequence construction expression are given by a sequence range, then the expression must have a type that conforms to type Integer. If the elements are given by a sequence element list, and the sequence construction expression has a non-empty type, then each expression in the list must have a type that either conforms to the type of the sequence construction expression or is convertible to it by bit string conversion or real conversion.
 
sequenceConstructionExpressionType
Type cannot be empty, cannot be a template and must either have a multiplicity indicator or be a template class instantiation.
If the type name of a sequence construction expression is not empty, then it must resolve to a non-template classifier. If the expression does not have multiplicity, then the type name must not be empty and the classifier to which it resolves must be the instantiation of a collection class.
 
sequenceExpansionExpressionAssignmentsAfterArgument
Assignments not allowed in sequence expansion argument.
The assignments after the argument expression of a sequence expansion expression must be the same as the assignments before the argument expression.
 
sequenceExpansionExpressionAssignmentsBeforeArgument

The assignments before the argument expression of a sequence expansion expression include those after the primary expression plus one for the expansion variable.
 
sequenceExpansionExpressionAssignmentsBeforePrimary

The assignments before the primary expression of a sequence expansion expression are the same as the assignments before the sequence expansion expression.
 
sequenceExpansionExpressionVariableName
Variable name already assigned.
The expansion variable name may not conflict with any name already assigned after the primary expression.
 
sequenceOperationExpressionArgumentCompatibility
One or more arguments are not compatible (in type and/or multiplicity) with corresponding parameters.
The type of an input argument expression of a sequence operation parameter must be assignable to its corresponding parameter. The type of an output parameter must be assignable to its corresponding argument expression. (Note that this implies that the type of an argument expression for an inout parameter must be the same as the type of that parameter.)
 
sequenceOperationExpressionAssignmentsAfter

A local name that is assigned in the primary expression of a sequence operation expression may not be assigned in any expression in the tuple of the sequence operation expression.
 
sequenceOperationExpressionAssignmentsBefore

The assignments before the primary expression of a sequence operation expression are the same as the assignments before the sequence operation expression.
 
sequenceOperationExpressionOperationReferent
Behavior name cannot be resolved or behavior is not compatible as a sequence operation.
There must be a single behavior that is a resolution of the operation qualified name of a sequence operation expression with a least one parameter, whose first parameter has direction in or inout, has multiplicity * and to which the target primary expression is assignable.
 
sequenceOperationExpressionTargetCompatibility
The target expression is not compatible with the operation.
If the first parameter of the referent has direction inout, then the parameter type must have the same type as the primary expression, the primary expression must have the form of a left-hand side and, if the equivalent left-hand side is for a local name, that name must already exist. The first parameter must be assignable to the effective left-hand side.
 
sequenceRangeAssignments
Local name cannot be assigned in more than one range expression.
A local name may be defined or reassigned in at most one of the expressions of a sequence range.
 
sequenceRangeExpressionMultiplicity
Range expression multiplicity upper bounds must be 1.
Both expression in a sequence range must have a multiplicity upper bound of 1.
 
sequenceReductionExpressionAssignmentsBefore

The assignments before the target expression of a sequence reduction expression are the same as the assignments before the sequence reduction expression.
 
sequenceReductionExpressionBehavior
Name must resolved to a behavior.
The behavior name in a sequence reduction expression must denote a behavior.
 
sequenceReductionExpressionBehaviorParameters
Behavior must have two in parameters and a return parameter, all with the type of the argument and multiplicity 1..1.
The referent behavior must have two in parameters, a return parameter and no other parameters. The parameters must all have the same type as the argument expression and multiplicity [1..1].
 
shiftExpressionOperands
First operand must have type BitString or Integer; second operand must have type Integer.
The first operand expression of a shift expression must have a type that conforms to the type BitString or Integer. The second operand expression must have that conforms to the type Integer.
 
superInvocationExpressionConstructorCall
Superclass constructor call not allowed here.
If the referent is the method of a constructor operation, the super invocation expression must occur in an expression statement at the start of the definition for the method of a constructor operation, such that any statements preceding it are also super constructor invocations.
 
superInvocationExpressionDestructorCall
Superclass destructor only allowed in the method of a destructor operation.
If the referent is the method of a destructor operation, the super invocation expression must occur in an within the method of a destructor operation.
 
superInvocationExpressionImplicitTarget
Implicit superclass constructor call only allowed in an operation method; class must have a single superclass; operation must be a constructor.
If the target is empty, the super invocation expression must occur within the method of an operation of a class with a single superclass and the referent must be the method of a constructor operation of that superclass. 
 
superInvocationExpressionOperation
Superclass operation cannot be resolved.
It must be possible to identify a single valid operation denoted by the target of a super invocation expression that satisfies the overloading resolution rules.
 
superInvocationExpressionQualification
Qualified name must resolved to a superclass.
If the target has a qualification, then this must resolve to one of the superclasses of the current context class.
 
tupleAssignmentsAfter

A name may be assigned in at most one argument expression of a tuple.
 
tupleAssignmentsBefore

The assignments before each expression in a tuple are the same as the assignments before the tuple, except in the case of a name expression that defines a new local name, in which case the assigned source for the new name is included in the assignments before the name expression. (Note that the assigned source for a new name is included before the name expression so that the nameExpressionResolution constraint is not violated.) The assignments before the tuple are the same as the assignments after the feature reference of the invocation of the tuple, if the invocation has one, or otherwise the assignments before the invocation.
 
tupleNullInputs
Null argument allowed for an in parameter only if it has multiplicity lower bound of 0.
An input parameter may only have a null argument if it has a multiplicity lower bound of 0.
 
tupleOutputs
Null argument not allowed for an inout parameter.
An output parameter may only have a null argument if it is an out parameter.
 
unaryExpressionAssignmentsBefore

The assignments before the operand of a unary expression are the same as those before the unary expression.
 
acceptBlockSignalNames
Signal names must resolve to signals.
All signal names in an accept block must resolve to signals.
 
acceptStatementAssignmentsAfter

If a name is assigned in any block of an accept statement, then the assigned source of the name after the accept statement is the accept statement itself.
 
acceptStatementAssignmentsBefore

The assignments before any block of an accept statement are the assignments before the accept statement.
 
acceptStatementCompoundAcceptLocalName

For a compound accept statement, a local name defined in an accept block has the accept block as its assigned source before the block associated with the accept block. The type of the local name is the effective common ancestor of the specified signals for that accept clause, if one exists, and it is untyped otherwise. However, the local name is considered unassigned after the accept statement.
 
acceptStatementContext
Accept statement only allowed in an active behavior or classifier behavior.
An accept statement can only be used within the definition of an active behavior or the classifier behavior of an active class.
 
acceptStatementEnclosedStatements

The enclosing statement for all statements in the blocks of all accept blocks of an accept statement is the accept statement.
 
acceptStatementNames
One or more signal instance names already assigned.
Any name defined in an accept block of an accept statement must be unassigned before the accept statement.
 
acceptStatementNewAssignments

Any name that is unassigned before an accept statement and is assigned in one or more blocks of the accept statement, has, after the accept statement, a type that is is the effective common ancestor of the types of the name in each block in which it is defined, with a multiplicity lower bound that is the minimum of the lower bound for the name in each block (where it is considered to have multiplicity lower bound of zero for blocks in which it is not defined), and a multiplicity upper bound that is the maximum for the name in each block in which it is defined. 

acceptStatementSignals
Signals cannot be referenced in more than one accept block.
No signal may be referenced in more than one accept block of an accept statement.
 
acceptStatementReceptions
Referenced signals must have receptions.
The containing behavior of an accept statement must have receptions for all signals from all accept blocks of the accept statement.
 
acceptStatementSimpleAcceptLocalName

A local name specified in the accept block of a simple accept statement has the accept statement as its assigned source after the accept statement. The type of the local name is the effective common ancestor of the specified signals, if one exists, and it is untyped otherwise.
 
blockAssignmentsBefore

The assignments before the first statement of a block are the same as the assignments before the block.
 
blockAssignmentsBeforeStatements

The assignments before each statement in a block other than the first are the same as the assignments after the previous statement.
 
blockStatementAssignmentsAfter

The assignments after a block statement are the same as the assignments after the block of the block statement.
 
blockStatementAssignmentsBefore

The assignments before the block of a block statement are the same as the assignments before the block statement.
 
blockStatementEnclosedStatements

The enclosing statement for all the statements in the block of a block statement is the block statement.
 
blockStatementParallelAssignments
Name cannot be assigned in a multiple parallel statements.
In a parallel block statement, any name assigned in one statement of the block may not be further assigned in any subsequent statement in the same block.
 
breakStatementNonparallelTarget
Target cannot have @parallel annotation.
The target of a break statement may not have a @parallel annotation.

breakStatementTargetDerivation
Break only allowed in a switch, while, do or for statement.
The target of a break statement is the innermost switch, while, do or for statement enclosing the break statement (which must exist).
 
classifyStatementAssignmentsAfter

The assignments after a classify statement are the same as the assignments after its expression.
 
classifyStatementAssignmentsBefore

The assignments before the expression of a classify statement are the same as the assignments before the statement.
 
classifyStatementClasses
From and to class must be disjoint subclasses of target type.
All the from and to classes of a classify statement must be subclasses of the type of the target expression and none of them may have a common superclass that is a subclass of the type of the target expression (that is, they must be disjoint subclasses).
 
classifyStatementClassNames
From and to names must resolve to classes.
All qualified names listed in the from or to lists of a classify statement must resolve to classes.
 
classifyStatementExpression
Target expression must have a class as its type and multiplicity upper bound of 1.
The expression in a classify statement must have a class as its type and multiplicity upper bound of 1.
 
concurrentClausesAssignmentsBefore

The assignments before the condition of each of the clauses in a set of concurrent clauses are the same as the assignments before the concurrent clauses.
 
concurrentClausesConditionAssignments

The same name may not be assigned in more than one conditional expression within the same concurrent set of clauses.
 
doStatementAssignmentsAfter

If the assigned source for a name after the condition expression is different than before the do statement, then the assigned source of the name after the do statement is the do statement. Otherwise it is the same as before the do statement.
 
doStatementAssignmentsBefore

The assignments before the block of a do statement are the same as the assignments before the do statement, except that any local names with a multiplicity lower bound of 0 after the condition expression are adjusted to also have a multiplicity lower bound of 0 before the block. The assignments before the condition expression of a do statement are the same assignments after the block. The assignments after the do statement are adjusted for known null and non-null names and type classifications due to the condition expression being false.
 
doStatementCondition
Condition expression must have type Boolean and multiplicity 1..1.
The condition expression of a do statement must have a type that conforms to type Boolean and multiplicity [1..1].
 
doStatementEnclosedStatements

The enclosing statement for all statements in the body of a do statement are the do statement.
 
emptyStatementAssignmentsAfter

The assignments after and empty statement are the same as the assignments before the statement.
 
expressionStatementAssignmentsAfter

The assignments after an expression statement are the same as the assignments after its expression.
 
expressionStatementAssignmentsBefore

The assignments before the expression of an expression statement are the same as the assignments before the statement.
 
forStatementAssignmentsAfter

The loop variables are unassigned after a for statement. Other than the loop variables, if the assigned source for a name after the body of a for statement is the same as after the for variable definitions, then the assigned source for the name after the for statement is the same as after the for variable definitions. If name has a different assigned source after the body of the for statement than after the for variable definitions, then the assigned source after the for statement is the for statement itself.
 
forStatementAssignmentsBefore

The assignments before a loop variable definition in a for statement are the same as before the for statement.  The assignments before the body of the statement include all the assignments before the statement plus any new assignments from the loop variable definitions, except that, if the statement is parallel, the assigned sources of any names given in @parallel annotations are changed to be the for statement itself.
 
forStatementEnclosedStatements

The enclosing statement for all statements in the body of a for statement are the for statement.
 
forStatementLoopVariables

The assigned sources for loop variables after the body of a for statement must be the for statement (the same as before the body). 
 
forStatementParallelAnnotationNames
@parallel names cannot have multiplicity upper bound 1 and can only by used with an add behavior.
A @parallel annotation of a for statement may include a list of names. Each such name must be already assigned after the loop variable definitions of the for statement, with a multiplicity upper bound 1. These names may only be used within the body of the for statement as the first argument for the CollectionFunctions::add behavior.
 
forStatementParallelAssignmentsAfter
Only @parallel names can be updated in a parallel for statement.
If, after the loop variable definitions of a parallel for statement, a name has an assigned source, then it must have the same assigned source after the block of the for statement. Other than for names defined in the @parallel annotation of the for statement, the assigned source for such names is the same after the for statement as before it. Any names defined in the @parallel annotation have the for statement itself as their assigned source after the for statement. Other than names given in the @parallel annotation, if a name is unassigned after the loop variable definitions, then it is considered unassigned after the for statement, even if it is assigned in the block of the for statement.
 
forStatementVariableDefinitions

The isFirst attribute of the first loop variable definition for a for statement is true while the isFirst attribute is false for any other definitions.
 
ifStatementAssignmentsAfter

Any name that is unassigned before an if statement and is assigned in one or more clauses of the if statement, has, after the if statement, a type that is is the effective common ancestor of the types of the name in each clause in which it is defined. For a name that has an assigned source after any clause of an if statement that is different than before that clause, then the assigned source after the if statement is the if statement, with a multiplicity lower bound that is the minimum of the lower bound for the name in each clause and a multiplicity upper bound that is the maximum for the name in each clause (where the name is considered to have multiplicity [0..0] for clauses in which it is not defined and unchanged multiplicity for an implicit final clause, unless the if statement is assured). Otherwise, the assigned source of a name after the if statement is the same as before the if statement.

ifStatementAssignmentsBefore

The assignments before each non-final clause of an if statement are the same as the assignments before the if statement, adjusted for known nulls and non-nulls and type classifications due to the failure of the conditions in all previous sets of concurrent clauses. If the statement has a final clause, then the assignments before that clause are also the same as the assignments before the if statement, adjusted for the failure of the conditions of all previous clauses.
 
ifStatementEnclosedStatements

The enclosing statement of all the statements in the bodies of all non-final clauses and in the final clause (if any) of an if statement is the if statement.
 
inLineStatementAssignmentsAfter

The assignments after an in-line statement are the same as the assignments before the statement.
 
localNameDeclarationStatementAssignmentsAfter

The assignments after a local name declaration statement are the assignments after the expression of the statement plus a new assignment for the local name defined by the statement. The assigned source for the local name is the local name declaration statement. The local name has the type denoted by the type name if this is not empty and is untyped otherwise. The multiplicity lower bound of the local name is 0 if the expression has a lower bound of 0, otherwise it is 1. If the statement has multiplicity, then the multiplicity upper bound of the local name is *, otherwise it is 1.
 
localNameDeclarationStatementAssignmentsBefore

The assignments before the expression of a local name declaration statement are the same as the assignments before the statement.
 
localNameDeclarationStatementExpressionMultiplicity
Right-hand side multiplicity upper bound must not be greater than 1.
If a local name declaration statement does not have multiplicity, then the multiplicity of upper bound of the assigned expression must not be greater than 1.
 
localNameDeclarationStatementLocalName
Name is already assigned or a parameter.
The local name in a local name declaration statement must be unassigned before the statement and before the expression in the statement. It must remain unassigned after the expression.

localNameDeclarationStatementType
Type name must resolve to a non-template classifier compatible with the right-hand side.
If the type name in a local name declaration statement is not empty, then it must resolve to a non-template classifier and the expression must be assignable to that classifier.
 
localNameDeclarationExpressionType

If the expression of a local name declaration statement is an instance creation expression with no constructor, and the type of the statement is a class or (structured) data type, then the referent of the expression is the type of the statement. If the expression of a local name declaration statement is a sequence construction expression with no type name, but with non-empty elements, then the type of the expression is the type of the statement and the expression has multiplicity if and only if the statement does.

loopVariableDefinitionAssignmentsBefore

The assignments before the expressions of a loop variable definition are the assignments before the loop variable definition. 
 
loopVariableDefinitionDeclaredType
Expression type must conform to declared loop variable type.
If the type of a loop variable definition is not inferred, then the first expression of the definition must have a type that conforms to the declared type.
 
loopVariableDefinitionRangeExpressions
Range expressions must have type Integer and multiplicity upper bound of 1; same name cannot be assigned in both expressions.
If a loop variable definition has two expressions, then both expressions must have that conforms to type Integer and a multiplicity upper bound of 1, and  no name may be newly assigned or reassigned in more than one of the expressions.
 
loopVariableDefinitionTypeName
Type name must resolve to a non-template classifier.
If a loop variable definition has a type name, then this name must resolve to a non-template classifier.
 
loopVariableDefinitionVariable
Loop variable name already assigned.
The variable name given in a loop variable definition must be unassigned after the expression or expressions in the definition.
 
nonFinalClauseAssignmentsBeforeBody

The assignments before the body of a non-final clause are the assignments after the condition, adjusted for known null and non-null names and type classifications due to the condition being true.
 
nonFinalClauseConditionLocalNames
Local names cannot be defined in condition expression.
If a name is unassigned before the condition expression of a non-final clause, then it must be unassigned after that expression (i.e., new local names may not be defined in the condition).
 
nonFinalClauseConditionType
Condition expression must have type Boolean and multiplicity 1..1.
The condition of a non-final clause must have a type that conforms to type Boolean and multiplicity [1..1].
 
returnStatementAssignmentsAfter

The assignments after a return statement are the same as the assignments after the expression of the return statement.
 
returnStatementAssignmentsBefore

The assignments before the expression of a return statement are the same as the assignments before the statement.
 
returnStatementContext
Expression is not compatible (in type and/or multiplicity) with return parameter.
If the behavior containing the return statement has a return parameter, then the return statement must have an expression, and the expression must be assignable to that return parameter.
 
statementAnnotationsAllowed
One or more annotations not allowed for this statement.
All the annotations of a statement must be allowed, as given by the annotationAllowed operation for the statement.
 
statementUniqueAssignments

No name may be assigned more than once before or after a statement.
 
switchClauseAssignmentsBefore

The assignments before any case expression of a  switch clause are the same as the assignments before the clause. The assignments before the block of a switch clause are the assignments after all case expressions.
 
switchClauseCaseLocalNames
Local names cannot be defined in case expressions.
If a name is unassigned before a switch clause, then it must be unassigned after all case expressions of the clause (i.e., new local names may not be defined in case expressions).
 
switchClauseCases
Case expressions multiplicity upper bounds must be no greater than 1.
All the case expressions of a switch clause must have a multiplicity no greater than 1.
 
switchStatementAssignments

Any name that is unassigned before a switch statement and is assigned in one or more clauses of the switch statement, has, after the switch statement, a type that is is the effective common ancestor of the types of the name in each clause in which it is defined.

switchStatementAssignmentsAfter

If a name has an assigned source after any clause of a switch statement that is different than before that clause (including newly defined names), the assigned source after the switch statement is the switch statement, with a multiplicity lower bound that is the minimum of the lower bound for the name in each clause and a multiplicity upper bound that is the maximum for the name in each clause (where the name is considered to have multiplicity [0..0] for clauses in which it is not defined and unchanged multiplicity for an implicit defaul clause, unless the switch statement is assured). Otherwise, the assigned source of a name after the switch statement is the same as before the switch statement.

switchStatementAssignmentsBefore

The assignments before the condition of all clauses of a switch statement are the same as the assignments after the expression of the switch statement.
 
switchStatementCaseAssignments
A local name cannot be assigned in more than one case expression.
The same local name may not be assigned in more than one case expression in a switch statement.
 
switchStatementEnclosedStatements

A switch statement is the enclosing statement for the statements in all of its switch clauses.
 
switchStatementExpression
Switch expression multiplicity must be no greater than 1.
A switch statement expression must have a multiplicity no greater than 1.

whileStatementAssignmentsAfter

f the assigned source for a name after the block of a while statement, then the assigned source of the name after the while statement is the while statement. Otherwise it is the same as before the block.  If a name is unassigned before the block of a while statement and assigned after the block, then it has multiplicity lower bound of 0 after the while statement. Otherwise, the assignments after the while statement are adjusted for known null and non-null names and type classifications due to the condition expression being false.
 
whileStatementAssignmentsBefore

The assignments before the condition expression of a while statement are the same as the assignments before the while statement, except that any local names with a multiplicity lower bound of 0 after the block are adjusted to also have a multiplicity lower bound of 0 before the condition expression. The assignments before the block of the while statement are the same as the assignments after the condition expression, adjusted for known null and non-null names and type classifications due to the condition expression being true.
 
whileStatementCondition
Condition expression must have type Boolean and multiplicity 1..1.
The condition expression of a while statement must have a type that conforms to type Boolean and multiplicity [1..1].
 
whileStatementEnclosedStatements

The enclosing statement for all statements in the body of a while statement are the while statement.
 
activeClassDefinitionClassifierBehavior
Concrete active class must have classifier behavior.
If an active class definition is not abstract, then it must have a classifier behavior.

activityDefinitionEffectiveBodyAssignmentsBefore

The assignments before the effective body of an activity definition include an assignment for each "in" or "inout" formal parameter of the activity definition, with the formal parameter as the assigned source.
 
activityDefinitionPrimitive
Primitive activity definition cannot have a body.
If an activity definition is primitive, then it must have a body that is empty.

activityDefinitionReturn
A return value is required.
If an activity definition has a return parameter with a multiplicity lower bound greater than 0, then the effective body of the activity definition must have a return value.
 
activityDefinitionSpecialization
Cannot have a specialization list.
An activity definition may not have a specialization list.
 
associationDefinitionSpecializationReferent
Can only specialize associations.
The specialization referents of an association definition must all be associations.
 
classDefinitionAbstractMember
Concrete class cannot have abstract operations.
If a class definition is not abstract, then no member operations (owned or inherited) of the class definition may be abstract.
 
classDefinitionSpecializationReferent
Can only specialize classes; only active classes can specialize active classes.
The specialization referents of a class definition must all be classes. A class definition may not have any referents that are active classes unless this is an active class definition.
 
classifierDefinitionInheritedMembers

The members of a classifier definition include non-private members inherited from the classifiers it specializes. The visibility of inherited members is as specified in the UML Superstructure, 7.3.8. Elements inherited from external classifiers are treated as imported members.
 
classifierDefinitionSpecialization
Can only specialize non-template classifiers.
Each name listed in the specialization list for a classifier definition must have a single classifier referent. None of these referents may be templates.
 
dataTypeDefinitionPrimitive
Primitive data type definitions cannot have attributes.
If a data type is primitive, then it may not have any owned members.
 
dataTypeDefinitionSpecializationReferent
Can only specialize data types.
The specialization referents of a data type definition must all be data types.
 
elementImportReferenceReferent
Imported element must be a packageable element.
The referent of an element import reference must be a packageable element.
 
enumerationDefinitionSpecializationReferent
Can only specialize enumerations.
The specialization referents of an enumeration definition must all be enumerations.

formalParameterAssignmentAfterBody
Out parameter must be assigned a value.
If a formal parameter has direction "out" and a multiplicity lower bound greater than 0, and its owning activity or operation definition has an effective body, then there must be an assignment for the formal parameter after the effective body that has a multiplicity greater than 0.
 
importedMemberNotStub

An imported element is not a stub.
 
importReferenceReferent
Import reference cannot be resolved or is not visible.
The referent name of an import reference must resolve to a single element with public or empty visibility.
 
memberAnnotations
One or more stereotype annotations not allowed for this member.
All stereotype annotations for a member must be allowed, as determined using the stereotypeAllowed operation.
 
memberExternal
External member cannot be a stub.
If a member is external then it must be a stub.
 
memberPrimitive
Primitive member may not be a stub or a template.
If a member is primitive, then it may not be a stub and it may not have any owned members that are template parameters.
 
memberStub
Stub must have a matching subunit.
If a member is a stub and is not external, then there must be a single subunit with the same qualified name as the stub that matches the stub, as determined by the matchForStub operation.
 
memberStubStereotypes
Stub stereotype annotations must be different than any on its subunit.
If a member is a stub, then it must not have any stereotype annotations that are the same as its subunit. Two stereotype annotations are the same if they are for the same stereotype.
 
namespaceDefinitionMemberDistinguishability
Members must be distinguishable.
The members of a namespace must be distinguishable as determined by the Member::isDistinguishableFrom operation.

operationDefinitionAbstractOperation
Abstract operation cannot have a body.
If an operation definition is abstract, then its body must be empty.
 
operationDefinitionConstructor
Redefined operations must be constructors.
If an operation definition is a constructor, any redefined operation for it must also be a constructor. The body of a constructor may contain an alternative constructor invocation for another constructor in the same class or super constructor invocations for constructors in immediate superclasses.
 
operationDefinitionConstructorDestructor
Cannot be both a constructor and a destructor.
An operation definition cannot be both a constructor and a destructor.
 
operationDefinitionDestructor
Redefined operations must be destructors.
If an operation definition is a destructor, any redefined operation for it must also be a destructor. 
 
operationDefinitionEffectiveBodyAssignmentsBefore

The assignments before the effective body of an operation definition include an assignment for each "in" or "inout" formal parameter of the operation definition, with the formal parameter as the assigned source.
 
operationDefinitionNamespace
Namespace must be a class.
The namespace for an operation definition must be a class definition.
 
operationDefinitionRedefinedOperations
Redefined operations must have matching parameters.
The redefined operations of an operation definition must have formal parameters that match each of the formal parameters of this operation definition, in order. Two formal parameters match if they have the same direction, name, multiplicity bounds, ordering, uniqueness and type reference.
 
operationDefinitionRedefinition
Redefinition names must resolve to non-private superclass operations.
Each name in the redefinition list of an operation definition must have a single referent that is an operation. This operation must be a non-private operation that is a member of a specialization referent of the class definition of the operation definition. 

operationDefinitionReturn
A return value is required.
If an operation definition has a return parameter with a multiplicity lower bound greater than 0, then the effective body of the operation definition must have a return value.

packageImportReferenceReferent
Name must resolve to a package.
The referent of a package import must be a package.
 
propertyDefinitionInitializer
Initializer expression must be compatible.
If a property definition has an initializer, then the initializer expression must be assignable to the property definition. There are no assignments before an initializer expression.

propertyDefinitionInitializerType

If the initializer of a property definition is an instance creation expression with no constructor, and the type of the property definition is a class or (structured) data type, then the referent of the expression is the type of the property definition. If the initializer of a property definition is a sequence construction expression with no type name, but with non-empty elements, then the type of the expression is the type of the property definition and the expression has multiplicity if and only if the multiplicity upper bound of the property definition is greater than 1.

receptionDefinitionSignalName
Signal name must resolve to a non-template signal.
The signal name for a reception definition must have a single referent that is a signal. This referent must not be a template.
 
signalDefinitionSpecializationReferent
Can only specialize signals.
The specialization referents of a signal definition must all be signals. 

stereotypeAnnotationApply
All names must resolve to profiles.
If the stereotype name of a stereotype annotation is "apply", then it must have a name list and all of the names in the list must resolve to profiles.
 
stereotypeAnnotationExternal
Only tagged value allowed is "file".
If the stereotype name of a stereotype annotation is "external", then it may optionally have a single tagged value with the name "file" and no operator.
 
stereotypeAnnotationNames
Argument names cannot be resolved or are not compatible with stereotype.
If a stereotype annotation has a stereotype and a list of names, then all the names in the list must resolve to visible model elements and the stereotype must have a single attribute with a (metaclass) type and multiplicity that are consistent with the types and number of the elements denoted by the given names.

stereotypeAnnotationPrimitive
Cannot have tagged values or argument names.
If the stereotype name of a stereotype annotation is "primitive", then it may not have tagged values or names.
 
stereotypeAnnotationStereotypeName
Stereotype name cannot be resolved.
The stereotype name of a stereotype annotation must either be one of "apply", "primitive" or "external", or it must denote a single stereotype from a profile applied to an enclosing package. The stereotype name does not need to be qualified if there is only one applied profile with a stereotype of that name or if the there is a standard UML profile with the name.
 
stereotypeAnnotationTaggedValues
Tagged values must have stereotype attribute names and legal values.
If a stereotype annotation has a stereotype and tagged values, then the each tagged value must have the name of an attribute of the stereotype and a value that is legally interpretable for the type of that attribute.
  
typedElementDefinitionTypeName
Type name must resolve to a non-template classifier.
The type name of a typed element definition must have a single classifier referent. This referent may not be a template.
 
unitDefinitionImplicitImports

Unless the unit definition is a model library, it has private package import references for all the sub-packages of the Alf::Library package.
 
unitDefinitionNamespace
Namespace name must resolve to UML namespace or Alf unit with appropriate stub.
The declared namespace name for a unit definition, if any, must resolve to a UML namespace or an Alf unit definition. If it is an Alf unit definition, then it must have a stub for this unit definition.
 
