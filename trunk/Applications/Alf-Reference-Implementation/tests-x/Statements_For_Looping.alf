/**
 * Test for statements.
 **/
active class Statements_Looping {

    // Supporting declarations *************************************************
    
	private class Sensor {
		private reading: Integer[0..1];
		@Create public Sensor(in reading: Integer[0..1]) {
			this.reading = reading;
		}
		public getNextReading(): Integer[0..1] { return this.reading; }
    }
	private class ActivityEdgeInstance {
		public token: Integer;
		public sendOffer(in token: Integer) {
			this.token = token;
		}
	}
	
    private activity processRecord(in index: Integer) { }
    
	//**************************************************************************

    public test(
    	out readings: Integer[*], out sum: Integer, out i: Integer,
    	out outgoingEdges: ActivityEdgeInstance[*],
    	out SnEven: Integer[*], out SnOdd: Integer[*]) {
    
      // Setup
	  noiseLimit = 1;
	  sensors = Sensor[]{new Sensor(1), new Sensor(2), new Sensor(null)};
	  reading = +0;
	  readings = null;
	  recordCount = 10;
	  sum = 0;
	  i = 1;
	  outgoingEdges = ActivityEdgeInstance[]{new ActivityEdgeInstance(), new ActivityEdgeInstance()};
	  tokens = Integer[]{1, 2, 3};
	  SLower = Integer[]{4, 5, 6};
	  SUpper = Integer[]{1, 2, 3};
	  SnEven = null;
	  SnOdd = null;
	  V = Integer[]{10, 20, 30};
	  // *****
	      
	  for (s in sensors) {
        reading = s.getNextReading();
	  	if (reading->notEmpty()) {
		  	readings->add(reading);
	  	}
	  	/*
	    if (reading->isEmpty()) {
	      break;
	    }
	    if (reading > noiseLimit) {
	      readings->add(reading);
	    }
	    */
	  }
	  
	  for (j in 1..recordCount) {
	    sum = sum + j;
	  }
	  
	  for (ActivityEdgeInstance outgoingEdge: outgoingEdges) {
	    outgoingEdge.sendOffer(tokens->at(i));
	    i++;
	  }
	  
	  //@parallel 
	  for (outgoingEdge in outgoingEdges, token in tokens) {
	    outgoingEdge.sendOffer(outgoingEdge.token + token);
	  }
	  
	  //@parallel(SnEven,SnOdd)
	  for (lower in SLower, upper in SUpper, root in V) {
	    //@parallel 
	    {
	      add(SnEven, lower+upper);
	      SnOdd->add((lower-upper)*root);
	    }
	  }
	  
    }
} do {
	this.test();
}
