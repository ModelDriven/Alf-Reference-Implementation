
DOCUMENT START
TOKENS
/*********************
 * LEXICAL STRUCTURE *
 *********************/

/* WHITE SPACE */<DEFAULT,IN_STATEMENT_ANNOTATION,IN_IN_LINE_ANNOTATION> SKIP : {
" "
| "\t"
| "\f"
}

<DEFAULT> SKIP : {
"\n"
| "\r"
}

/* STATEMENT ANNOTATIONS */<DEFAULT> TOKEN : {
<SLASH_SLASH_AT: "//@"> : IN_STATEMENT_ANNOTATION
| <SLASH_STAR_AT: "/*@"> : IN_IN_LINE_ANNOTATION
}

<IN_STATEMENT_ANNOTATION> TOKEN : {
<EOL: ("//" (~["\n","\r"])*)? ("\n" | "\r" ("\n")?)> : DEFAULT
}

<IN_IN_LINE_ANNOTATION> SKIP : {
<("//" (~["\n","\r"])*)? ("\n" | "\r" ("\n")?)> : IN_DOCUMENTATION_COMMENT
}

/* COMMENTS */<DEFAULT> SKIP : {
<"/**" ~["/"]> : IN_DOCUMENTATION_COMMENT
}

<DEFAULT> MORE : {
"//" : IN_END_OF_LINE_COMMENT
| "/*" : IN_IN_LINE_COMMENT
}

<IN_END_OF_LINE_COMMENT> SKIP : {
<END_OF_LINE_COMMENT: "\n" | "\r" ("\n")?> : DEFAULT
}

<IN_END_OF_LINE_COMMENT> MORE : {
<~[]>
}

<IN_IN_LINE_COMMENT> MORE : {
<~["*"]>
| "*" : IN_IN_LINE_COMMENT_STAR
}

<IN_IN_LINE_COMMENT_STAR> MORE : {
<~["/"]> : IN_IN_LINE_COMMENT
}

<IN_IN_LINE_COMMENT_STAR> SKIP : {
<IN_LINE_COMMENT: "/"> : DEFAULT
}

<IN_DOCUMENTATION_COMMENT> MORE : {
<~["*"]>
| "*" : IN_DOCUMENTATION_COMMENT_STAR
}

<IN_DOCUMENTATION_COMMENT_STAR> TOKEN : {
<DOCUMENTATION_COMMENT: "/"> : DEFAULT
}

<IN_DOCUMENTATION_COMMENT_STAR> MORE : {
<~["/"]> : IN_DOCUMENTATION_COMMENT
}

/* RESERVED WORDS */<DEFAULT,IN_STATEMENT_ANNOTATION,IN_IN_LINE_ANNOTATION> TOKEN : {
<ABSTRACT: "abstract">
| <ACCEPT: "accept">
| <ACTIVE: "active">
| <ACTIVITY: "activity">
| <ALL_INSTANCES: "allInstances">
| <ANY: "any">
| <AS: "as">
| <ASSOC: "assoc">
| <BREAK: "break">
| <CASE: "case">
| <CLASS: "class">
| <CLASSIFY: "classify">
| <CLEAR_ASSOC: "clearAssoc">
| <COMPOSE: "compose">
| <CREATE_LINK: "createLink">
| <DATATYPE: "datatype">
| <DEFAULT_: "default">
| <DESTROY_LINK: "destroyLink">
| <DO: "do">
| <ELSE: "else">
| <ENUM: "enum">
| <FOR: "for">
| <FROM: "from">
| <HASTYPE: "hastype">
| <IF: "if">
| <IMPORT: "import">
| <IN: "in">
| <INOUT: "inout">
| <INSTANCEOF: "instanceof">
| <LET: "let">
| <NAMESPACE: "namespace">
| <NEW: "new">
| <NONUNIQUE: "nonunique">
| <NULL: "null">
| <OR: "or">
| <ORDERED: "ordered">
| <OUT: "out">
| <PACKAGE: "package">
| <PRIVATE: "private">
| <PROTECTED: "protected">
| <PUBLIC: "public">
| <RECEIVE: "receive">
| <REDEFINES: "redefines">
| <REDUCE: "reduce">
| <RETURN: "return">
| <SEQUENCE: "sequence">
| <SPECIALIZES: "specializes">
| <SUPER: "super">
| <SIGNAL: "signal">
| <SWITCH: "switch">
| <THIS: "this">
| <TO: "to">
| <WHILE: "while">
}

/* NAMES */<DEFAULT,IN_STATEMENT_ANNOTATION,IN_IN_LINE_ANNOTATION> TOKEN : {
<IDENTIFIER: <IDENTIFIER_LETTER> (<IDENTIFIER_LETTER_OR_DIGIT>)*>
| <#IDENTIFIER_LETTER_OR_DIGIT: <IDENTIFIER_LETTER> | <DIGIT>>
| <#IDENTIFIER_LETTER: ["a"-"z","A"-"Z","_"]>
| <#DIGIT: "0" | <NONZERO_DIGIT>>
| <#NONZERO_DIGIT: ["1"-"9"]>
| <UNRESTRICTED_NAME: "\'" (<NAME_CHARACTER>)+ "\'">
| <#NAME_CHARACTER: ~["\'","\\"] | <ESCAPE_CHARACTER>>
| <#ESCAPE_CHARACTER: "\\" <ESCAPED_CHARACTER>>
| <#ESCAPED_CHARACTER: ["\'","\"","b","f","n","\\"]>
}

/* PRIMITIVE LITERALS */<DEFAULT,IN_STATEMENT_ANNOTATION,IN_IN_LINE_ANNOTATION> TOKEN : {
<BOOLEAN_LITERAL: "true" | "false">
| <BINARY_LITERAL: ("0b" | "0B") <BINARY_DIGIT> (("_")? <BINARY_DIGIT>)*>
| <#BINARY_DIGIT: ["0","1"]>
| <HEX_LITERAL: ("0x" | "0X") <HEX_DIGIT> (("_")? <HEX_DIGIT>)*>
| <#HEX_DIGIT: <DIGIT> | ["a"-"f","A"-"F"]>
| <OCTAL_LITERAL: "0" (("_")? <OCTAL_DIGIT>)+>
| <#OCTAL_DIGIT: ["0"-"7"]>
| <DECIMAL_LITERAL: "0" | <NONZERO_DIGIT> (("_")? <DIGIT>)*>
| <STRING_LITERAL: "\"" (<STRING_CHARACTER>)* "\"">
| <#STRING_CHARACTER: ~["\"","\\"]>
}

/* PUNCTUATION */<DEFAULT,IN_STATEMENT_ANNOTATION,IN_IN_LINE_ANNOTATION> TOKEN : {
<LPAREN: "(">
| <RPAREN: ")">
| <LBRACE: "{">
| <RBRACE: "}">
| <LBRACKET: "[">
| <RBRACKET: "]">
| <SEMICOLON: ";">
| <COMMA: ",">
| <DOT: ".">
| <DOUBLE_DOT: "..">
| <COLON: ":">
| <DOUBLE_COLON: "::">
| <ARROW: "->">
| <THICK_ARROW: "=>">
}

/* OPERATORS */<DEFAULT,IN_STATEMENT_ANNOTATION,IN_IN_LINE_ANNOTATION> TOKEN : {
<ASSIGN: "=">
| <GT: ">">
| <LT: "<">
| <BANG: "!">
| <TILDE: "~">
| <HOOK: "?">
| <AT: "@">
| <DOLLAR: "$">
| <EQ: "==">
| <LE: "<=">
| <GE: ">=">
| <NE: "!=">
| <SC_OR: "||">
| <SC_AND: "&&">
| <INCR: "++">
| <DECR: "--">
| <PLUS: "+">
| <MINUS: "-">
| <STAR: "*">
| <SLASH: "/">
| <LOGICAL_AND: "&">
| <LOGICAL_OR: "|">
| <XOR: "^">
| <REM: "%">
| <LSHIFT: "<<">
| <RSHIFT: ">>">
| <URSHIFT: ">>>">
| <PLUSASSIGN: "+=">
| <MINUSASSIGN: "-=">
| <STARASSIGN: "*=">
| <SLASHASSIGN: "/=">
| <ANDASSIGN: "&=">
| <ORASSIGN: "|=">
| <XORASSIGN: "^=">
| <REMASSIGN: "%=">
| <LSHIFTASSIGN: "<<=">
| <RSHIFTASSIGN: ">>=">
| <URSHIFTASSIGN: ">>>=">
}

NON-TERMINALS
/***************
 *    NAMES    *
 ***************/	Name	:=	( <IDENTIFIER> | <UNRESTRICTED_NAME> )
	QualifiedName	:=	UnqualifiedName ( ( ColonQualifiedNameCompletion | DotQualifiedNameCompletion ) )?
	PotentiallyAmbiguousQualifiedName	:=	UnqualifiedName ( ( ColonQualifiedNameCompletion | DotQualifiedNameCompletion ) )?
	ColonQualifiedName	:=	UnqualifiedName ColonQualifiedNameCompletion
	ColonQualifiedNameCompletion	:=	( <DOUBLE_COLON> NameBinding )+
	DotQualifiedName	:=	UnqualifiedName DotQualifiedNameCompletion
	DotQualifiedNameCompletion	:=	( <DOT> NameBinding )+
	UnqualifiedName	:=	NameBinding
	NameBinding	:=	Name ( TemplateBinding )?
	TemplateBindingLookahead	:=	<LT> ( QualifiedName ( <COMMA> | <GT> ) | Name <THICK_ARROW> )
	TemplateBinding	:=	<LT> ( NamedTemplateBinding | PositionalTemplateBinding ) <GT>
	PositionalTemplateBinding	:=	QualifiedName ( <COMMA> QualifiedName )*
	NamedTemplateBinding	:=	TemplateParameterSubstitution ( <COMMA> TemplateParameterSubstitution )*
	TemplateParameterSubstitution	:=	Name <THICK_ARROW> QualifiedName
/***************
 * EXPRESSIONS *
 ***************/	Expression	:=	UnaryExpression ExpressionCompletion
	NonNameExpression	:=	NonNameUnaryExpression ExpressionCompletion
	NameToExpressionCompletion	:=	( NameToPrimaryExpression )? PrimaryToExpressionCompletion
	PrimaryToExpressionCompletion	:=	PostfixExpressionCompletion ExpressionCompletion
	ExpressionCompletion	:=	( AssignmentExpressionCompletion | ConditionalExpressionCompletion )
/* PRIMARY EXPRESSIONS */	PrimaryExpression	:=	( NameOrPrimaryExpression | BaseExpression | ParenthesizedExpression ) PrimaryExpressionCompletion
	BaseExpression	:=	( LiteralExpression | ThisExpression | SuperInvocationExpression | InstanceCreationOrSequenceConstructionExpression | SequenceAnyExpression )
	NameToPrimaryExpression	:=	( <DOT> ( LinkOperationCompletion | ClassExtentExpressionCompletion ) | SequenceConstructionExpressionCompletion | BehaviorInvocation )
	PrimaryExpressionCompletion	:=	( Feature ( FeatureInvocation )? | SequenceOperationOrReductionOrExpansion | Index )*
/* LITERAL EXPRESSIONS */	LiteralExpression	:=	( <BOOLEAN_LITERAL> | <DECIMAL_LITERAL> | <BINARY_LITERAL> | <OCTAL_LITERAL> | <HEX_LITERAL> | <STRING_LITERAL> | <STAR> )
/* NAME EXPRESSIONS */	NameOrPrimaryExpression	:=	PotentiallyAmbiguousQualifiedName ( NameToPrimaryExpression )?
/* THIS EXPRESSIONS */	ThisExpression	:=	<THIS> ( Tuple )?
/* PARENTHESIZED EXPRESSIONS */	ParenthesizedExpression	:=	<LPAREN> Expression <RPAREN>
/* PROPERTY ACCESS EXPRESSIONS */	Feature	:=	<DOT> NameBinding
/* INVOCATION EXPRESSIONS */	Tuple	:=	<LPAREN> ( NamedTupleExpressionList | ( PositionalTupleExpressionList )? ) <RPAREN>
	PositionalTupleExpressionList	:=	Expression PositionalTupleExpressionListCompletion
	PositionalTupleExpressionListCompletion	:=	( <COMMA> Expression )*
	NamedTupleExpressionList	:=	NamedExpression ( <COMMA> NamedExpression )*
	NamedExpression	:=	Name <THICK_ARROW> Expression
	BehaviorInvocation	:=	Tuple
	FeatureInvocation	:=	Tuple
	SuperInvocationExpression	:=	<SUPER> ( <DOT> QualifiedName )? Tuple
/* INSTANCE CREATION EXPRESSIONS */	InstanceCreationOrSequenceConstructionExpression	:=	<NEW> QualifiedName ( SequenceConstructionExpressionCompletion | Tuple )
/* LINK OPERATION EXPRESSIONS */	LinkOperationCompletion	:=	LinkOperation LinkOperationTuple
	LinkOperation	:=	( <CREATE_LINK> | <DESTROY_LINK> | <CLEAR_ASSOC> )
	LinkOperationTuple	:=	<LPAREN> ( Name ( Index ( <THICK_ARROW> IndexedNamedExpressionListCompletion | PrimaryToExpressionCompletion PositionalTupleExpressionListCompletion ) | <THICK_ARROW> IndexedNamedExpressionListCompletion ) | PositionalTupleExpressionList )? <RPAREN>
	IndexedNamedExpressionListCompletion	:=	Expression ( <COMMA> IndexedNamedExpression )*
	IndexedNamedExpression	:=	Name ( Index )? <THICK_ARROW> Expression
/* CLASS EXTENT EXPRESSIONS */	ClassExtentExpressionCompletion	:=	<ALL_INSTANCES> <LPAREN> <RPAREN>
/* SEQUENCE CONSTRUCTION EXPRESSIONS */	SequenceAnyExpression	:=	( <ANY> SequenceConstructionExpressionCompletion | <NULL> )
	SequenceConstructionExpressionCompletion	:=	( MultiplicityIndicator )? <LBRACE> ( SequenceElements )? <RBRACE>
	MultiplicityIndicator	:=	<LBRACKET> <RBRACKET>
	SequenceElements	:=	( Expression ( <DOUBLE_DOT> Expression | SequenceElementListCompletion ) | SequenceInitializationExpression SequenceElementListCompletion )
	SequenceElementListCompletion	:=	( <COMMA> SequenceElement )* ( <COMMA> )?
	SequenceElement	:=	( Expression | SequenceInitializationExpression )
	SequenceInitializationExpression	:=	( <NEW> )? <LBRACE> SequenceElements <RBRACE>
/* SEQUENCE ACCESS EXPRESSIONS */	Index	:=	<LBRACKET> Expression <RBRACKET>
/* SEQUENCE OPERATION, REDUCTION AND EXPANSION EXPRESSIONS */	SequenceOperationOrReductionOrExpansion	:=	<ARROW> ( QualifiedName Tuple | <REDUCE> ( <ORDERED> )? QualifiedName | <IDENTIFIER> Name <LPAREN> Expression <RPAREN> )
/* INCREMENT OR DECREMENT EXPRESSIONS */	PostfixExpressionCompletion	:=	PrimaryExpressionCompletion ( PostfixOperation )?
	PostfixOperation	:=	AffixOperator
	PrefixExpression	:=	AffixOperator PrimaryExpression
	AffixOperator	:=	( <INCR> | <DECR> )
/* UNARY EXPRESSIONS */	UnaryExpression	:=	( PostfixOrCastExpression | NonPostfixNonCastUnaryExpression )
	PostfixOrCastExpression	:=	( NonNamePostfixOrCastExpression | NameOrPrimaryExpression PostfixExpressionCompletion )
	NonNameUnaryExpression	:=	( NonNamePostfixOrCastExpression | NonPostfixNonCastUnaryExpression )
	NonNamePostfixOrCastExpression	:=	( <LPAREN> ( <ANY> <RPAREN> CastCompletion | PotentiallyAmbiguousQualifiedName ( <RPAREN> CastCompletion | NameToExpressionCompletion <RPAREN> PostfixExpressionCompletion ) | NonNameExpression <RPAREN> PostfixExpressionCompletion ) | BaseExpression PostfixExpressionCompletion )
	NonPostfixNonCastUnaryExpression	:=	( PrefixExpression | NumericUnaryExpression | BooleanNegationExpression | BitStringComplementExpression | IsolationExpression )
	BooleanNegationExpression	:=	<BANG> UnaryExpression
	BitStringComplementExpression	:=	<TILDE> UnaryExpression
	NumericUnaryExpression	:=	NumericUnaryOperator UnaryExpression
	NumericUnaryOperator	:=	( <PLUS> | <MINUS> )
	IsolationExpression	:=	<DOLLAR> UnaryExpression
	CastExpression	:=	<LPAREN> TypeName <RPAREN> CastCompletion
	CastCompletion	:=	( PostfixOrCastExpression | BooleanNegationExpression | BitStringComplementExpression | IsolationExpression )
/* ARITHMETIC EXPRESSIONS */	MultiplicativeExpression	:=	UnaryExpression MultiplicativeExpressionCompletion
	MultiplicativeExpressionCompletion	:=	( MultiplicativeOperator UnaryExpression )*
	MultiplicativeOperator	:=	( <STAR> | <SLASH> | <REM> )
	AdditiveExpression	:=	UnaryExpression AdditiveExpressionCompletion
	AdditiveExpressionCompletion	:=	MultiplicativeExpressionCompletion ( AdditiveOperator MultiplicativeExpression )*
	AdditiveOperator	:=	( <PLUS> | <MINUS> )
/* SHIFT EXPRESSIONS */	ShiftExpression	:=	UnaryExpression ShiftExpressionCompletion
	ShiftExpressionCompletion	:=	AdditiveExpressionCompletion ( ShiftOperator AdditiveExpression )*
	ShiftOperator	:=	( <LSHIFT> | <RSHIFT> | <URSHIFT> )
/* RELATIONAL EXPRESSIONS */	RelationalExpression	:=	UnaryExpression RelationalExpressionCompletion
	RelationalExpressionCompletion	:=	ShiftExpressionCompletion ( RelationalOperator ShiftExpression )?
	RelationalOperator	:=	( <LT> | <GT> | <LE> | <GE> )
/* CLASSIFICATION EXPRESSIONS */	ClassificationExpression	:=	UnaryExpression ClassificationExpressionCompletion
	ClassificationExpressionCompletion	:=	RelationalExpressionCompletion ( ClassificationOperator QualifiedName )?
	ClassificationOperator	:=	( <INSTANCEOF> | <HASTYPE> )
/* EQUALITY EXPRESSIONS */	EqualityExpression	:=	UnaryExpression ClassificationExpressionCompletion
	EqualityExpressionCompletion	:=	ClassificationExpressionCompletion ( EqualityOperator ClassificationExpression )*
	EqualityOperator	:=	( <EQ> | <NE> )
/* LOGICAL EXPRESSIONS */	AndExpression	:=	UnaryExpression AndExpressionCompletion
	AndExpressionCompletion	:=	EqualityExpressionCompletion ( <LOGICAL_AND> EqualityExpression )*
	ExclusiveOrExpression	:=	UnaryExpression ExclusiveOrExpressionCompletion
	ExclusiveOrExpressionCompletion	:=	AndExpressionCompletion ( <XOR> AndExpression )*
	InclusiveOrExpression	:=	UnaryExpression InclusiveOrExpressionCompletion
	InclusiveOrExpressionCompletion	:=	ExclusiveOrExpressionCompletion ( <LOGICAL_OR> ExclusiveOrExpression )*
/* CONDITIONAL LOGICAL EXPRESSIONS */	ConditionalAndExpression	:=	UnaryExpression ConditionalAndExpressionCompletion
	ConditionalAndExpressionCompletion	:=	InclusiveOrExpressionCompletion ( <SC_AND> InclusiveOrExpression )*
	ConditionalOrExpression	:=	UnaryExpression ConditionalOrExpressionCompletion
	ConditionalOrExpressionCompletion	:=	ConditionalAndExpressionCompletion ( <SC_OR> ConditionalAndExpression )*
/* CONDITIONAL-TEST EXPRESSIONS */	ConditionalExpression	:=	UnaryExpression ConditionalExpressionCompletion
	ConditionalExpressionCompletion	:=	ConditionalOrExpressionCompletion ( <HOOK> Expression <COLON> ConditionalExpression )?
/* ASSIGNMENT EXPRESSIONS */	AssignmentExpressionCompletion	:=	AssignmentOperator Expression
	AssignmentOperator	:=	( <ASSIGN> | <PLUSASSIGN> | <MINUSASSIGN> | <STARASSIGN> | <SLASHASSIGN> | <REMASSIGN> | <ANDASSIGN> | <ORASSIGN> | <XORASSIGN> | <LSHIFTASSIGN> | <RSHIFTASSIGN> | <URSHIFTASSIGN> )
/**************
 * STATEMENTS *
 **************/	StatementSequence	:=	( DocumentedStatement )*
	DocumentedStatement	:=	( <DOCUMENTATION_COMMENT> )? Statement
	Statement	:=	( AnnotatedStatement | InLineStatement | BlockStatement | EmptyStatement | LocalNameDeclarationOrExpressionStatement | LocalNameDeclarationStatement | IfStatement | SwitchStatement | WhileStatement | ForStatement | DoStatement | BreakStatement | ReturnStatement | AcceptStatement | ClassifyStatement )
/* BLOCK */	Block	:=	<LBRACE> StatementSequence <RBRACE>
/* ANNOTATED STATEMENTS */	AnnotatedStatement	:=	<SLASH_SLASH_AT> Annotations <EOL> Statement
	Annotations	:=	Annotation ( <AT> Annotation )*
	Annotation	:=	<IDENTIFIER> ( <LPAREN> NameList <RPAREN> )?
	NameList	:=	Name ( <COMMA> Name )*
/* IN-LINE STATEMENTS */	InLineStatement	:=	<SLASH_STAR_AT> <IDENTIFIER> <LPAREN> Name <RPAREN> <DOCUMENTATION_COMMENT>
/* BLOCK STATEMENTS */	BlockStatement	:=	Block
/* EMPTY STATEMENTS */	EmptyStatement	:=	<SEMICOLON>
/* LOCAL NAME DECLARATION AND EXPRESSION STATEMENTS */	LocalNameDeclarationOrExpressionStatement	:=	( PotentiallyAmbiguousQualifiedName ( ( MultiplicityIndicator )? Name LocalNameDeclarationStatementCompletion | NameToExpressionCompletion <SEMICOLON> ) | NonNameExpression <SEMICOLON> )
	LocalNameDeclarationStatement	:=	<LET> Name <COLON> TypeName ( MultiplicityIndicator )? LocalNameDeclarationStatementCompletion
	LocalNameDeclarationStatementCompletion	:=	<ASSIGN> InitializationExpression <SEMICOLON>
	InitializationExpression	:=	( Expression | SequenceInitializationExpression | InstanceInitializationExpression )
	InstanceInitializationExpression	:=	<NEW> Tuple
/* IF STATEMENTS */	IfStatement	:=	<IF> SequentialClauses ( FinalClause )?
	SequentialClauses	:=	ConcurrentClauses ( <ELSE> <IF> ConcurrentClauses )*
	ConcurrentClauses	:=	NonFinalClause ( <OR> <IF> NonFinalClause )*
	NonFinalClause	:=	<LPAREN> Expression <RPAREN> Block
	FinalClause	:=	<ELSE> Block
/* SWITCH STATEMENTS */	SwitchStatement	:=	<SWITCH> <LPAREN> Expression <RPAREN> <LBRACE> ( SwitchClause )* ( SwitchDefaultClause )? <RBRACE>
	SwitchClause	:=	SwitchCase ( SwitchCase )* NonEmptyStatementSequence
	SwitchCase	:=	<CASE> Expression <COLON>
	SwitchDefaultClause	:=	<DEFAULT_> <COLON> NonEmptyStatementSequence
	NonEmptyStatementSequence	:=	( DocumentedStatement )+
/* WHILE STATEMENTS */	WhileStatement	:=	<WHILE> <LPAREN> Expression <RPAREN> Block
/* DO STATEMENTS */	DoStatement	:=	<DO> Block <WHILE> <LPAREN> Expression <RPAREN> <SEMICOLON>
/* FOR STATEMENTS */	ForStatement	:=	<FOR> <LPAREN> ForControl <RPAREN> Block
	ForControl	:=	LoopVariableDefinition ( <COMMA> LoopVariableDefinition )*
	LoopVariableDefinition	:=	( Name <IN> Expression ( <DOUBLE_DOT> Expression )? | QualifiedName Name <COLON> Expression )
/* BREAK STATEMENTS */	BreakStatement	:=	<BREAK> <SEMICOLON>
/* RETURN STATEMENTS */	ReturnStatement	:=	<RETURN> Expression <SEMICOLON>
/* ACCEPT STATEMENTS */	AcceptStatement	:=	AcceptClause ( SimpleAcceptStatementCompletion | CompoundAcceptStatementCompletion )
	SimpleAcceptStatementCompletion	:=	<SEMICOLON>
	CompoundAcceptStatementCompletion	:=	Block ( <OR> AcceptBlock )*
	AcceptBlock	:=	AcceptClause Block
	AcceptClause	:=	<ACCEPT> <LPAREN> ( Name <COLON> )? QualifiedNameList <RPAREN>
	ClassificationFromClause	:=	<FROM> QualifiedNameList
	ClassificationToClause	:=	<TO> QualifiedNameList
/* CLASSIFY STATEMENTS */	ClassifyStatement	:=	<CLASSIFY> Expression ClassificationClause <SEMICOLON>
	ClassificationClause	:=	ClassificationFromClause ( ClassificationToClause )?
		|	( ReclassifyAllClause )? ClassificationToClause
	ReclassifyAllClause	:=	<FROM> <STAR>
	QualifiedNameList	:=	QualifiedName ( <COMMA> QualifiedName )*
/*********
 * UNITS *
 *********/	UnitDefinition	:=	( NamespaceDeclaration )? ( ImportDeclaration )* ( <DOCUMENTATION_COMMENT> )? StereotypeAnnotations NamespaceDefinition <EOF>
	StereotypeAnnotations	:=	( StereotypeAnnotation )*
	StereotypeAnnotation	:=	<AT> QualifiedName ( <LPAREN> TaggedValues <RPAREN> )?
	TaggedValues	:=	QualifiedNameList
		|	TaggedValueList
	TaggedValueList	:=	TaggedValue ( "," TaggedValue )*
	TaggedValue	:=	Name <THICK_ARROW> ( <BOOLEAN_LITERAL> | <STRING_LITERAL> | <STAR> | ( <PLUS> | <MINUS> )? ( <DECIMAL_LITERAL> | <BINARY_LITERAL> | <OCTAL_LITERAL> | <HEX_LITERAL> ) )
	NamespaceDeclaration	:=	<NAMESPACE> QualifiedName <SEMICOLON>
	ImportDeclaration	:=	ImportVisibilityIndicator <IMPORT> ImportReference <SEMICOLON>
	ImportVisibilityIndicator	:=	( <PUBLIC> | <PRIVATE> )
	ImportReference	:=	( ColonQualifiedName ( <DOUBLE_COLON> <STAR> | AliasDefinition )? | DotQualifiedName ( <DOT> <STAR> | AliasDefinition )? | Name ( ( <DOUBLE_COLON> | <DOT> ) <STAR> | AliasDefinition )? )
	AliasDefinition	:=	<AS> Name
/* NAMESPACES */	NamespaceDefinition	:=	( PackageDefinition | ClassifierDefinition )
	VisibilityIndicator	:=	( ImportVisibilityIndicator | <PROTECTED> )
/* PACKAGES */	PackageDeclaration	:=	<PACKAGE> Name
	PackageDefinition	:=	PackageDeclaration PackageBody
	PackageDefinitionOrStub	:=	PackageDeclaration ( <SEMICOLON> | PackageBody )
	PackageBody	:=	<LBRACE> ( PackagedElement )* <RBRACE>
	PackagedElement	:=	( <DOCUMENTATION_COMMENT> )? StereotypeAnnotations ImportVisibilityIndicator PackagedElementDefinition
	PackagedElementDefinition	:=	( PackageDefinitionOrStub | ClassifierDefinitionOrStub )
/***************
 * CLASSIFIERS *
 ***************/	ClassifierDefinition	:=	( ClassDefinition | ActiveClassDefinition | DataTypeDefinition | EnumerationDefinition | AssociationDefinition | SignalDefinition | ActivityDefinition )
	ClassifierDefinitionOrStub	:=	( ClassDefinitionOrStub | ActiveClassDefinitionOrStub | DataTypeDefinitionOrStub | EnumerationDefinitionOrStub | AssociationDefinitionOrStub | SignalDefinitionOrStub | ActivityDefinitionOrStub )
	ClassifierSignature	:=	Name ( TemplateParameters )? ( SpecializationClause )?
	TemplateParameters	:=	<LT> ClassifierTemplateParameter ( <COMMA> ClassifierTemplateParameter )* <GT>
	ClassifierTemplateParameter	:=	( <DOCUMENTATION_COMMENT> )? Name ( <SPECIALIZES> QualifiedName )?
	SpecializationClause	:=	<SPECIALIZES> QualifiedNameList
/* CLASSES */	ClassDeclaration	:=	( <ABSTRACT> )? <CLASS> ClassifierSignature
	ClassDefinition	:=	ClassDeclaration ClassBody
	ClassDefinitionOrStub	:=	ClassDeclaration ( <SEMICOLON> | ClassBody )
	ClassBody	:=	<LBRACE> ( ClassMember )* <RBRACE>
	ClassMember	:=	( <DOCUMENTATION_COMMENT> )? StereotypeAnnotations ( VisibilityIndicator )? ClassMemberDefinition
	ClassMemberDefinition	:=	( ClassifierDefinitionOrStub | FeatureDefinitionOrStub )
/* ACTIVE CLASSES */	ActiveClassDeclaration	:=	( <ABSTRACT> )? <ACTIVE> <CLASS> ClassifierSignature
	ActiveClassDefinition	:=	ActiveClassDeclaration ActiveClassBody
	ActiveClassDefinitionOrStub	:=	ActiveClassDeclaration ( <SEMICOLON> | ActiveClassBody )
	ActiveClassBody	:=	<LBRACE> ( ActiveClassMember )* <RBRACE> ( <DO> BehaviorClause )?
	BehaviorClause	:=	( Block | Name )
	ActiveClassMember	:=	( <DOCUMENTATION_COMMENT> )? StereotypeAnnotations ( VisibilityIndicator )? ActiveClassMemberDefinition
	ActiveClassMemberDefinition	:=	( ClassMemberDefinition | ActiveFeatureDefinitionOrStub )
/* DATA TYPES */	DataTypeDeclaration	:=	( <ABSTRACT> )? <DATATYPE> ClassifierSignature
	DataTypeDefinition	:=	DataTypeDeclaration StructuredBody
	DataTypeDefinitionOrStub	:=	DataTypeDeclaration ( <SEMICOLON> | StructuredBody )
	StructuredBody	:=	<LBRACE> ( StructuredMember )* <RBRACE>
	StructuredMember	:=	( <DOCUMENTATION_COMMENT> )? StereotypeAnnotations ( <PUBLIC> )? PropertyDefinition
/* ASSOCIATIONS */	AssociationDeclaration	:=	( <ABSTRACT> )? <ASSOC> ClassifierSignature
	AssociationDefinition	:=	AssociationDeclaration StructuredBody
	AssociationDefinitionOrStub	:=	AssociationDeclaration ( <SEMICOLON> | StructuredBody )
/* ENUMERATIONS */	EnumerationDeclaration	:=	<ENUM> Name ( SpecializationClause )?
	EnumerationDefinition	:=	EnumerationDeclaration EnumerationBody
	EnumerationDefinitionOrStub	:=	EnumerationDeclaration ( <SEMICOLON> | EnumerationBody )
	EnumerationBody	:=	<LBRACE> EnumerationLiteralName ( <COMMA> EnumerationLiteralName )* <RBRACE>
	EnumerationLiteralName	:=	( <DOCUMENTATION_COMMENT> )? Name
/* SIGNALS */	SignalDeclaration	:=	( <ABSTRACT> )? <SIGNAL> ClassifierSignature
	SignalDefinition	:=	SignalDeclaration StructuredBody
	SignalDefinitionOrStub	:=	SignalDeclaration ( <SEMICOLON> | StructuredBody )
/* ACTIVITIES */	ActivityDeclaration	:=	<ACTIVITY> Name ( TemplateParameters )? FormalParameters ( <COLON> TypePart )?
	ActivityDefinition	:=	ActivityDeclaration Block
	ActivityDefinitionOrStub	:=	ActivityDeclaration ( <SEMICOLON> | Block )
	FormalParameters	:=	<LPAREN> ( FormalParameterList )? <RPAREN>
	FormalParameterList	:=	FormalParameter ( <COMMA> FormalParameter )*
	FormalParameter	:=	( <DOCUMENTATION_COMMENT> )? StereotypeAnnotations ParameterDirection Name <COLON> TypePart
	ParameterDirection	:=	( <IN> | <OUT> | <INOUT> )
/* FEATURES */	FeatureDefinitionOrStub	:=	( AttributeDefinition | OperationDefinitionOrStub )
	ActiveFeatureDefinitionOrStub	:=	( ReceptionDefinition | SignalReceptionDefinitionOrStub )
/* PROPERTIES */	PropertyDefinition	:=	PropertyDeclaration <SEMICOLON>
	AttributeDefinition	:=	PropertyDeclaration ( AttributeInitializer )? <SEMICOLON>
	AttributeInitializer	:=	<ASSIGN> InitializationExpression
	PropertyDeclaration	:=	Name <COLON> ( <COMPOSE> )? TypePart
	TypePart	:=	TypeName ( Multiplicity )?
	TypeName	:=	( QualifiedName | <ANY> )
	Multiplicity	:=	<LBRACKET> ( MultiplicityRange )? <RBRACKET> ( <ORDERED> ( <NONUNIQUE> )? | <NONUNIQUE> ( <ORDERED> )? | <SEQUENCE> )?
	MultiplicityRange	:=	( <DECIMAL_LITERAL> <DOUBLE_DOT> )? UnlimitedNaturalLiteral
	UnlimitedNaturalLiteral	:=	( <DECIMAL_LITERAL> | <STAR> )
/* OPERATIONS */	OperationDeclaration	:=	( <ABSTRACT> )? Name FormalParameters ( <COLON> TypePart )? ( RedefinitionClause )?
	OperationDefinitionOrStub	:=	OperationDeclaration ( <SEMICOLON> | Block )
	RedefinitionClause	:=	<REDEFINES> QualifiedNameList
/* RECEPTIONS */	ReceptionDefinition	:=	<RECEIVE> QualifiedName <SEMICOLON>
	SignalReceptionDeclaration	:=	<RECEIVE> <SIGNAL> Name ( SpecializationClause )?
	SignalReceptionDefinitionOrStub	:=	SignalReceptionDeclaration ( <SEMICOLON> | StructuredBody )

DOCUMENT END
