
DOCUMENT START
TOKENS
/*********************
 * LEXICAL STRUCTURE *
 *********************/



/* WHITE SPACE */



<DEFAULT,IN_STATEMENT_ANNOTATION,IN_IN_LINE_ANNOTATION> SKIP : {
" "
| "\t"
| "\f"
}

<DEFAULT> SKIP : {
"\n"
| "\r"
}

/* STATEMENT ANNOTATIONS */



<DEFAULT> TOKEN : {
<SLASH_SLASH_AT: "//@"> : IN_STATEMENT_ANNOTATION
| <SLASH_STAR_AT: "/*@"> : IN_IN_LINE_ANNOTATION
}

<IN_STATEMENT_ANNOTATION> TOKEN : {
<EOL: ("//" (~["\n","\r"])*)? ("\n" | "\r" ("\n")?)> : DEFAULT
}

<IN_IN_LINE_ANNOTATION> SKIP : {
<("//" (~["\n","\r"])*)? ("\n" | "\r" ("\n")?)> : IN_DOCUMENTATION_COMMENT
}

/* COMMENTS */



<DEFAULT> SKIP : {
<"/**" ~["/"]> : IN_DOCUMENTATION_COMMENT
}

<DEFAULT> MORE : {
"//" : IN_END_OF_LINE_COMMENT
| "/*" : IN_IN_LINE_COMMENT
}

<IN_END_OF_LINE_COMMENT> SKIP : {
<END_OF_LINE_COMMENT: "\n" | "\r" ("\n")?> : DEFAULT
}

<IN_END_OF_LINE_COMMENT> MORE : {
<~[]>
}

<IN_IN_LINE_COMMENT> MORE : {
<~["*"]>
| "*" : IN_IN_LINE_COMMENT_STAR
}

<IN_IN_LINE_COMMENT_STAR> MORE : {
<~["/"]> : IN_IN_LINE_COMMENT
}

<IN_IN_LINE_COMMENT_STAR> SKIP : {
<IN_LINE_COMMENT: "/"> : DEFAULT
}

<IN_DOCUMENTATION_COMMENT> MORE : {
<~["*"]>
| "*" : IN_DOCUMENTATION_COMMENT_STAR
}

<IN_DOCUMENTATION_COMMENT_STAR> TOKEN : {
<DOCUMENTATION_COMMENT: "/"> : DEFAULT
}

<IN_DOCUMENTATION_COMMENT_STAR> MORE : {
<~["/"]> : IN_DOCUMENTATION_COMMENT
}

/* RESERVED WORDS */



<DEFAULT,IN_STATEMENT_ANNOTATION,IN_IN_LINE_ANNOTATION> TOKEN : {
<ABSTRACT: "abstract">
| <ACCEPT: "accept">
| <ACTIVE: "active">
| <ACTIVITY: "activity">
| <ALL_INSTANCES: "allInstances">
| <ANY: "any">
| <AS: "as">
| <ASSOC: "assoc">
| <BREAK: "break">
| <CASE: "case">
| <CLASS: "class">
| <CLASSIFY: "classify">
| <COMPOSE: "compose">
| <DATATYPE: "datatype">
| <DEFAULT_: "default">
| <DO: "do">
| <ELSE: "else">
| <ENUM: "enum">
| <FOR: "for">
| <FROM: "from">
| <HASTYPE: "hastype">
| <IF: "if">
| <IMPORT: "import">
| <IN: "in">
| <INOUT: "inout">
| <INSTANCEOF: "instanceof">
| <LET: "let">
| <NAMESPACE: "namespace">
| <NEW: "new">
| <NONUNIQUE: "nonunique">
| <NULL: "null">
| <OR: "or">
| <ORDERED: "ordered">
| <OUT: "out">
| <PACKAGE: "package">
| <PRIVATE: "private">
| <PROTECTED: "protected">
| <PUBLIC: "public">
| <RECEIVE: "receive">
| <REDEFINES: "redefines">
| <RETURN: "return">
| <SPECIALIZES: "specializes">
| <SUPER: "super">
| <SIGNAL: "signal">
| <SWITCH: "switch">
| <THIS: "this">
| <TO: "to">
| <WHILE: "while">
| <COLLECTION_NAME: "Set" | "OrderedSet" | "Bag" | "Sequence" | "Option">
}

/* NAMES */



<DEFAULT,IN_STATEMENT_ANNOTATION,IN_IN_LINE_ANNOTATION> TOKEN : {
<IDENTIFIER: <IDENTIFIER_LETTER> (<IDENTIFIER_LETTER_OR_DIGIT>)*>
| <#IDENTIFIER_LETTER_OR_DIGIT: <IDENTIFIER_LETTER> | <DIGIT>>
| <#IDENTIFIER_LETTER: ["a"-"z","A"-"Z","_"]>
| <#DIGIT: ["0"-"9"]>
| <UNRESTRICTED_NAME: "\'" (<NAME_CHARACTER>)+ "\'">
| <#NAME_CHARACTER: ~["\'","\\"] | <ESCAPE_CHARACTER>>
| <#ESCAPE_CHARACTER: "\\" <ESCAPED_CHARACTER>>
| <#ESCAPED_CHARACTER: ["\'","\"","b","f","n","\\"]>
}

/* PRIMITIVE LITERALS */



<DEFAULT,IN_STATEMENT_ANNOTATION,IN_IN_LINE_ANNOTATION> TOKEN : {
<BOOLEAN_LITERAL: "true" | "false">
| <NATURAL_LITERAL: (<DIGIT>)+>
| <STRING_LITERAL: "\"" (<STRING_CHARACTER>)* "\"">
| <#STRING_CHARACTER: ~["\"","\\"]>
}

/* PUNCTUATION */



<DEFAULT,IN_STATEMENT_ANNOTATION,IN_IN_LINE_ANNOTATION> TOKEN : {
<LPAREN: "(">
| <RPAREN: ")">
| <LBRACE: "{">
| <RBRACE: "}">
| <LBRACKET: "[">
| <RBRACKET: "]">
| <SEMICOLON: ";">
| <COMMA: ",">
| <DOT: ".">
| <DOUBLE_DOT: "..">
| <COLON: ":">
| <DOUBLE_COLON: "::">
| <ARROW: "->">
| <THICK_ARROW: "=>">
}

/* OPERATORS */



<DEFAULT,IN_STATEMENT_ANNOTATION,IN_IN_LINE_ANNOTATION> TOKEN : {
<ASSIGN: "=">
| <GT: ">">
| <LT: "<">
| <BANG: "!">
| <HOOK: "?">
| <AT: "@">
| <DOLLAR: "$">
| <EQ: "==">
| <LE: "<=">
| <GE: ">=">
| <NE: "!=">
| <SC_OR: "||">
| <SC_AND: "&&">
| <INCR: "++">
| <DECR: "--">
| <PLUS: "+">
| <MINUS: "-">
| <STAR: "*">
| <SLASH: "/">
| <LOGICAL_AND: "&">
| <LOGICAL_OR: "|">
| <XOR: "^">
| <REM: "%">
| <LSHIFT: "<<">
| <PLUSASSIGN: "+=">
| <MINUSASSIGN: "-=">
| <STARASSIGN: "*=">
| <SLASHASSIGN: "/=">
| <ANDASSIGN: "&=">
| <ORASSIGN: "|=">
| <XORASSIGN: "^=">
| <REMASSIGN: "%=">
| <HASH: "#">
| <DOUBLE_HASH: "##">
}

NON-TERMINALS
/***************
 *    NAMES    *
 ***************/

 	Name	:=	( <IDENTIFIER> | <UNRESTRICTED_NAME> )
	QualifiedName	:=	( ColonQualifiedName | DotQualifiedName | Name )
	ColonQualifiedName	:=	Name ( <DOUBLE_COLON> Name )+
	DotQualifiedName	:=	Name ( <DOT> Name )+

/***************
 * EXPRESSIONS *
 ***************/

 	Expression	:=	( ColonQualifiedName UnambiguousQualifiedNameExpressionCompletion | DotQualifiedName AmbiguousQualifiedNameExpressionCompletion | Name NameExpressionCompletion | NonNameExpression )
	NonNameExpression	:=	( <LPAREN> ( <ANY> <RPAREN> CastCompletion ConditionalExpressionCompletion | ColonQualifiedName ( <RPAREN> CastCompletion ConditionalExpressionCompletion | UnambiguousQualifiedNameExpressionCompletion <RPAREN> ExpressionCompletion ) | DotQualifiedName ( <RPAREN> CastCompletion ConditionalExpressionCompletion | AmbiguousQualifiedNameExpressionCompletion <RPAREN> ExpressionCompletion ) | Name ( <RPAREN> CastCompletion ConditionalExpressionCompletion | NameExpressionCompletion <RPAREN> ExpressionCompletion ) | NonNameExpression <RPAREN> ExpressionCompletion ) | NonPostfixNonCastUnaryExpression ConditionalExpressionCompletion | BaseExpression ExpressionCompletion )
	ExpressionCompletion	:=	( Index ExpressionCompletion | NonIndexExpressionCompletion )
	NonIndexExpressionCompletion	:=	( Feature FeatureExpressionCompletion | NonFeatureExpressionCompletion )
	NonFeatureExpressionCompletion	:=	( CollectionOperationOrExpansion ExpressionCompletion | PostfixOperation ConditionalExpressionCompletion )
	UnambiguousQualifiedNameExpressionCompletion	:=	( Assignment | CollectionExpressionCompletion ExpressionCompletion | ExpressionCompletion )
	AmbiguousQualifiedNameExpressionCompletion	:=	( Assignment | CollectionExpressionCompletion ExpressionCompletion | Index IndexFeatureExpressionCompletion | NonIndexExpressionCompletion )
	NameExpressionCompletion	:=	( Assignment | CollectionExpressionCompletion ExpressionCompletion | Index ExpressionCompletion | NonFeatureExpressionCompletion )
	FeatureExpressionCompletion	:=	( Assignment | Index IndexFeatureExpressionCompletion | FeatureInvocation ExpressionCompletion | NonIndexExpressionCompletion )
	IndexFeatureExpressionCompletion	:=	( Assignment | Index ExpressionCompletion | NonIndexExpressionCompletion )
	
/* PRIMARY AND COLLECTION EXPRESSIONS */

    BaseExpression	:=	( LiteralExpression | ThisExpression | SuperInvocationExpression | InstanceCreationOrCollectionValueExpression | ReductionExpression | CollectionAnyExpression )
	CollectionExpressionCompletion	:=	( ClassExtentExpressionCompletion | CollectionValueExpressionCompletion | BehaviorInvocation )
	CollectionModifier	:=	( Feature ( FeatureInvocation )? | CollectionOperationOrExpansion | Index )
	
/* LITERAL EXPRESSIONS */

	LiteralExpression	:=	( <BOOLEAN_LITERAL> | <NATURAL_LITERAL> | <STRING_LITERAL> | <STAR> )
	
/* NAME EXPRESSIONS */



	NameOrCollectionExpression	:=	( ColonQualifiedName | DotQualifiedName | Name ) ( CollectionExpressionCompletion )?
	
/* THIS EXPRESSIONS */

	ThisExpression	:=	<THIS> ( Tuple )?
	
/* PARENTHESIZED EXPRESSIONS */

	ParenthesizedExpression	:=	<LPAREN> Expression <RPAREN>
	
/* PROPERTY ACCESS EXPRESSIONS */

	Feature	:=	<DOT> Name
	
/* INVOCATION EXPRESSIONS */

	Tuple	:=	<LPAREN> ( NamedExpressionList | ( ExpressionList )? ) <RPAREN>
	ExpressionList	:=	Expression ExpressionListCompletion
	ExpressionListCompletion	:=	( <COMMA> Expression )*
	NamedExpressionList	:=	NamedExpression ( <COMMA> NamedExpression )*
	NamedExpression	:=	Name <THICK_ARROW> Expression
	BehaviorInvocation	:=	Tuple
	FeatureInvocation	:=	Tuple
	SuperInvocationExpression	:=	<SUPER> ( <DOT> QualifiedName )? Tuple
	
/* INSTANCE CREATION EXPRESSIONS */

	InstanceCreationOrCollectionValueExpression	:=	<NEW> QualifiedName ( CollectionValueExpressionCompletion | Tuple )

/* REDUCTION EXPRESSIONS */

	ReductionExpression	:=	ReductionOperator QualifiedName <LPAREN> Expression <RPAREN>
	ReductionOperator	:=	( <HASH> | <DOUBLE_HASH> )

/* CLASS EXTENT EXPRESSIONS */

	ClassExtentExpressionCompletion	:=	<DOT> <ALL_INSTANCES> <LPAREN> <RPAREN>

/* COLLECTION VALUE EXPRESSIONS */

	CollectionAnyExpression	:=	( <ANY> CollectionValueExpressionCompletion | <NULL> )
	CollectionValueExpressionCompletion	:=	MultiplicityIndicator <LBRACE> ( CollectionElements )? <RBRACE>
	CollectionElements	:=	Expression ( <DOUBLE_DOT> Expression | ( <COMMA> Expression )* )

/* COLLECTION ACCESS EXPRESSIONS */

	Index	:=	<LBRACKET> Expression <RBRACKET>

/* COLLECTION OPERATION AND EXPANSION EXPRESSIONS */

	CollectionOperationOrExpansion	:=	<ARROW> <IDENTIFIER> ( Name Tuple | CollectionOperationTuple )
	CollectionOperationTuple	:=	<LPAREN> ( CollectionOperationPositionalTuple | Name ( Index ( <THICK_ARROW> IndexedNamedExpressionListCompletion | ExpressionCompletion ExpressionListCompletion ) | <THICK_ARROW> IndexedNamedExpressionListCompletion | NonFeatureExpressionCompletion ExpressionListCompletion ) )? <RPAREN>
	CollectionOperationPositionalTuple	:=	( ColonQualifiedName UnambiguousQualifiedNameExpressionCompletion | DotQualifiedName AmbiguousQualifiedNameExpressionCompletion | NonNameExpression ) ExpressionListCompletion
	IndexedNamedExpressionListCompletion	:=	Expression ( <COMMA> IndexedNamedExpression )*
	IndexedNamedExpression	:=	Name ( Index )? <THICK_ARROW> Expression

/* POSTFIX EXPRESSIONS */

	PostfixOrCastExpression	:=	( <LPAREN> ( <ANY> <RPAREN> CastCompletion | ColonQualifiedName ( <RPAREN> CastCompletion | UnambiguousQualifiedNameExpressionCompletion <RPAREN> PostfixCompletion ) | DotQualifiedName ( <RPAREN> CastCompletion | AmbiguousQualifiedNameExpressionCompletion <RPAREN> PostfixCompletion ) | Name ( <RPAREN> CastCompletion | NameExpressionCompletion <RPAREN> PostfixCompletion ) | NonNameExpression <RPAREN> PostfixCompletion ) | NameOrCollectionExpression PostfixCompletion | BaseExpression PostfixCompletion )
	PostfixCompletion	:=	( CollectionModifier )* PostfixOperation
	PostfixOperation	:=	( AffixOperator )*
	AffixOperator	:=	( <INCR> | <DECR> )

/* UNARY EXPRESSIONS */

	UnaryExpression	:=	( PostfixOrCastExpression | NonPostfixNonCastUnaryExpression )
	NonPostfixNonCastUnaryExpression	:=	( PrefixedExpression | NumericUnaryExpression | BooleanNegationExpression | IsolationExpression )
	PrefixedExpression	:=	AffixOperator UnaryExpression
	BooleanNegationExpression	:=	<BANG> UnaryExpression
	NumericUnaryExpression	:=	NumericUnaryOperator UnaryExpression
	NumericUnaryOperator	:=	( <PLUS> | <MINUS> )
	IsolationExpression	:=	<DOLLAR> UnaryExpression
	CastExpression	:=	<LPAREN> TypeName <RPAREN> CastCompletion
	CastCompletion	:=	( PostfixOrCastExpression | BooleanNegationExpression | IsolationExpression )

/* MULTIPLICATIVE OPERATORS */

	MultiplicativeExpression	:=	UnaryExpression MultiplicativeExpressionCompletion

/* ADDED */

	MultiplicativeExpressionCompletion	:=	( MultiplicativeOperator UnaryExpression )*
	MultiplicativeOperator	:=	( <STAR> | <SLASH> | <REM> )

/* ADDITIVE OPERATORS */

	AdditiveExpression	:=	UnaryExpression AdditiveExpressionCompletion
	AdditiveExpressionCompletion	:=	MultiplicativeExpressionCompletion ( AdditiveOperator MultiplicativeExpression )*
	AdditiveOperator	:=	( <PLUS> | <MINUS> )

/* RELATIONAL OPERATORS */

	RelationalExpression	:=	UnaryExpression RelationalExpressionCompletion
	RelationalExpressionCompletion	:=	AdditiveExpressionCompletion ( RelationalOperator AdditiveExpression )*
	RelationalOperator	:=	( <LT> | <GT> | <LE> | <GE> )
	ClassificationExpression	:=	UnaryExpression ClassificationExpressionCompletion
	ClassificationExpressionCompletion	:=	RelationalExpressionCompletion ( ClassificationOperator QualifiedName )?
	ClassificationOperator	:=	( <INSTANCEOF> | <HASTYPE> )

/* EQUALITY OPERATORS */

	EqualityExpression	:=	UnaryExpression ClassificationExpressionCompletion
	EqualityExpressionCompletion	:=	ClassificationExpressionCompletion ( EqualityOperator ClassificationExpression )*
	EqualityOperator	:=	( <EQ> | <NE> )

/* LOGICAL OPERATORS */

	AndExpression	:=	UnaryExpression AndExpressionCompletion
	AndExpressionCompletion	:=	EqualityExpressionCompletion ( <LOGICAL_AND> EqualityExpression )*
	ExclusiveOrExpression	:=	UnaryExpression ExclusiveOrExpressionCompletion
	ExclusiveOrExpressionCompletion	:=	AndExpressionCompletion ( <XOR> AndExpression )*
	InclusiveOrExpression	:=	UnaryExpression InclusiveOrExpressionCompletion
	InclusiveOrExpressionCompletion	:=	ExclusiveOrExpressionCompletion ( <LOGICAL_OR> ExclusiveOrExpression )*

/* CONDITIONAL-AND OPERATOR */

	ConditionalAndExpression	:=	UnaryExpression ConditionalAndExpressionCompletion
	ConditionalAndExpressionCompletion	:=	InclusiveOrExpressionCompletion ( <SC_AND> InclusiveOrExpression )*

/* CONDITIONAL-OR OPERATOR */

	ConditionalOrExpression	:=	UnaryExpression ConditionalOrExpressionCompletion
	ConditionalOrExpressionCompletion	:=	ConditionalAndExpressionCompletion ( <SC_OR> ConditionalAndExpression )*

/* CONDITIONAL-TEST OPERATOR */

	ConditionalExpression	:=	UnaryExpression ConditionalExpressionCompletion
	ConditionalExpressionCompletion	:=	ConditionalOrExpressionCompletion ( <HOOK> Expression <COLON> ConditionalExpression )?

/* ASSIGNMENT OPERATORS */

	Assignment	:=	AssignmentOperator Expression
	AssignmentOperator	:=	( <ASSIGN> | <PLUSASSIGN> | <MINUSASSIGN> | <STARASSIGN> | <SLASHASSIGN> | <REMASSIGN> | <ANDASSIGN> | <ORASSIGN> | <XORASSIGN> )

/**************
 * STATEMENTS *
 **************/

	StatementSequence	:=	( DocumentedStatement )*
	DocumentedStatement	:=	( <DOCUMENTATION_COMMENT> )? Statement
	Statement	:=	( AnnotatedStatement | InLineStatement | BlockStatement | EmptyStatement | LocalNameDeclarationOrExpressionStatement | LocalNameDeclarationStatement | IfStatement | SwitchStatement | WhileStatement | ForStatement | DoStatement | BreakStatement | ReturnStatement | AcceptStatement | ClassifyStatement )

/* BLOCK */

	Block	:=	<LBRACE> StatementSequence <RBRACE>

/* ANNOTATED STATEMENTS */

	AnnotatedStatement	:=	<SLASH_SLASH_AT> Annotations <EOL> Statement
	Annotations	:=	Annotation ( <AT> Annotation )*
	Annotation	:=	<IDENTIFIER> ( <LPAREN> NameList <RPAREN> )?
	NameList	:=	Name ( <COMMA> Name )*

/* IN-LINE STATEMENTS */

	InLineStatement	:=	<SLASH_STAR_AT> <IDENTIFIER> <LPAREN> Name <RPAREN> <DOCUMENTATION_COMMENT>

/* BLOCK STATEMENTS */

	BlockStatement	:=	Block

/* EMPTY STATEMENTS */

	EmptyStatement	:=	<SEMICOLON>

/* LOCAL NAME DECLARATION AND EXPRESSION STATEMENTS */

	LocalNameDeclarationOrExpressionStatement	:=	( ColonQualifiedName ( ( MultiplicityIndicator )? Name LocalNameDeclarationStatementCompletion | UnambiguousQualifiedNameExpressionCompletion <SEMICOLON> ) | DotQualifiedName ( ( MultiplicityIndicator )? Name LocalNameDeclarationStatementCompletion | AmbiguousQualifiedNameExpressionCompletion <SEMICOLON> ) | Name ( ( MultiplicityIndicator )? Name LocalNameDeclarationStatementCompletion | NameExpressionCompletion <SEMICOLON> ) | NonNameExpression <SEMICOLON> )
	MultiplicityIndicator	:=	<LBRACKET> <RBRACKET>
	LocalNameDeclarationStatement	:=	<LET> Name <COLON> TypeName ( MultiplicityIndicator )? LocalNameDeclarationStatementCompletion
	LocalNameDeclarationStatementCompletion	:=	<ASSIGN> Expression <SEMICOLON>

/* IF STATEMENTS */

	IfStatement	:=	<IF> SequentialClauses ( FinalClause )?
	SequentialClauses	:=	ConcurrentClauses ( <ELSE> <IF> ConcurrentClauses )*
	ConcurrentClauses	:=	NonFinalClause ( <OR> <IF> NonFinalClause )*
	NonFinalClause	:=	<LPAREN> Expression <RPAREN> Block
	FinalClause	:=	<ELSE> Block

/* SWITCH STATEMENTS */

	SwitchStatement	:=	<SWITCH> <LPAREN> Expression <RPAREN> <LBRACE> ( SwitchClause )* ( SwitchDefaultClause )? <RBRACE>
	SwitchClause	:=	SwitchCase ( SwitchCase )* Block
	SwitchCase	:=	<CASE> Expression <COLON>
	SwitchDefaultClause	:=	<DEFAULT_> <COLON> Block

/* WHILE STATEMENTS */

	WhileStatement	:=	<WHILE> <LPAREN> Expression <RPAREN> Block

/* DO STATEMENTS */

	DoStatement	:=	<DO> Block <WHILE> <LPAREN> Expression <RPAREN> <SEMICOLON>

/* FOR STATEMENTS */

	ForStatement	:=	<FOR> <LPAREN> ForControl <RPAREN> Block
	ForControl	:=	ForVariableDefinition ( <COMMA> ForVariableDefinition )* ( <WHILE> Expression )?
	ForVariableDefinition	:=	( Name <IN> Expression ( <DOUBLE_DOT> Expression )? | QualifiedName Name <COLON> Expression )

/* BREAK STATEMENTS */

	BreakStatement	:=	<BREAK> <SEMICOLON>

/* RETURN STATEMENTS */

	ReturnStatement	:=	<RETURN> Expression <SEMICOLON>

/* ACCEPT STATEMENTS */

	AcceptStatement	:=	AcceptClause ( SimpleAcceptStatementCompletion | CompoundAcceptStatementCompletion )
	SimpleAcceptStatementCompletion	:=	<SEMICOLON>
	CompoundAcceptStatementCompletion	:=	Block ( <OR> AcceptBlock )*
	AcceptBlock	:=	AcceptClause Block
	AcceptClause	:=	<ACCEPT> <LPAREN> ( Name <COLON> )? QualifiedNameList <RPAREN>
	ClassificationFromClause	:=	<FROM> QualifiedNameList
	ClassificationToClause	:=	<TO> QualifiedNameList

/* CLASSIFY STATEMENTS */

	ClassifyStatement	:=	<CLASSIFY> Expression ClassificationClause <SEMICOLON>
	ClassificationClause	:=	ClassificationFromClause ( ClassificationToClause )?
		|	( ReclassifyAllClause )? ClassificationToClause
	ReclassifyAllClause	:=	<FROM> <STAR>
	QualifiedNameList	:=	QualifiedName ( <COMMA> QualifiedName )*

/*********
 * UNITS *
 *********/

	UnitDefinition	:=	( NamespaceDeclaration )? ( ImportDeclaration )* ( <DOCUMENTATION_COMMENT> )? StereotypeAnnotations NamespaceDefinition <EOF>
	StereotypeAnnotations	:=	( StereotypeAnnotation )*
	StereotypeAnnotation	:=	<AT> QualifiedName ( <LPAREN> TaggedValues <RPAREN> )?
	TaggedValues	:=	QualifiedNameList
		|	TaggedValueList
	TaggedValueList	:=	TaggedValue ( "," TaggedValue )*
	TaggedValue	:=	Name <THICK_ARROW> ( <BOOLEAN_LITERAL> | <STRING_LITERAL> | <STAR> | ( <PLUS> | <MINUS> )? <NATURAL_LITERAL> )
	NamespaceDeclaration	:=	<NAMESPACE> QualifiedName <SEMICOLON>
	ImportDeclaration	:=	ImportVisibilityIndicator <IMPORT> ImportReference <SEMICOLON>
	ImportVisibilityIndicator	:=	( <PUBLIC> | <PRIVATE> )
	ImportReference	:=	( ColonQualifiedName ( <DOUBLE_COLON> <STAR> | AliasDefinition )? | DotQualifiedName ( <DOT> <STAR> | AliasDefinition )? | Name ( ( <DOUBLE_COLON> | <DOT> ) <STAR> | AliasDefinition )? )
	AliasDefinition	:=	<AS> Name

/* NAMESPACES */

	NamespaceDefinition	:=	( PackageDefinition | ClassifierDefinition )
	VisibilityIndicator	:=	( ImportVisibilityIndicator | <PROTECTED> )

/* PACKAGES */

	PackageDeclaration	:=	<PACKAGE> Name
	PackageDefinition	:=	PackageDeclaration PackageBody
	PackageDefinitionOrStub	:=	PackageDeclaration ( <SEMICOLON> | PackageBody )
	PackageBody	:=	<LBRACE> ( PackagedElement )* <RBRACE>
	PackagedElement	:=	( <DOCUMENTATION_COMMENT> )? StereotypeAnnotations ImportVisibilityIndicator PackagedElementDefinition
	PackagedElementDefinition	:=	( PackageDefinitionOrStub | ClassifierDefinitionOrStub )

/***************
 * CLASSIFIERS *
 ***************/

	ClassifierDefinition	:=	( ClassDefinition | ActiveClassDefinition | DataTypeDefinition | EnumerationDefinition | AssociationDefinition | SignalDefinition | ActivityDefinition )
	ClassifierDefinitionOrStub	:=	( ClassDefinitionOrStub | ActiveClassDefinitionOrStub | DataTypeDefinitionOrStub | EnumerationDefinitionOrStub | AssociationDefinitionOrStub | SignalDefinitionOrStub | ActivityDefinitionOrStub )

/* CLASSES */

	ClassDeclaration	:=	( <ABSTRACT> )? <CLASS> Name ( SpecializationClause )?
	SpecializationClause	:=	<SPECIALIZES> QualifiedNameList
	ClassDefinition	:=	ClassDeclaration ClassBody
	ClassDefinitionOrStub	:=	ClassDeclaration ( <SEMICOLON> | ClassBody )
	ClassBody	:=	<LBRACE> ( ClassMember )* <RBRACE>
	ClassMember	:=	( <DOCUMENTATION_COMMENT> )? StereotypeAnnotations ( VisibilityIndicator )? ClassMemberDefinition
	ClassMemberDefinition	:=	( ClassifierDefinitionOrStub | FeatureDefinitionOrStub )

/* ACTIVE CLASSES */

	ActiveClassDeclaration	:=	( <ABSTRACT> )? <ACTIVE> <CLASS> Name ( SpecializationClause )?
	ActiveClassDefinition	:=	ActiveClassDeclaration ActiveClassBody
	ActiveClassDefinitionOrStub	:=	ActiveClassDeclaration ( <SEMICOLON> | ActiveClassBody )
	ActiveClassBody	:=	<LBRACE> ( ActiveClassMember )* <RBRACE> ( <DO> BehaviorClause )?
	BehaviorClause	:=	( Block | Name )
	ActiveClassMember	:=	( <DOCUMENTATION_COMMENT> )? StereotypeAnnotations ( VisibilityIndicator )? ActiveClassMemberDefinition
	ActiveClassMemberDefinition	:=	( ClassMemberDefinition | ActiveFeatureDefinitionOrStub )

/* DATA TYPES */

	DataTypeDeclaration	:=	( <ABSTRACT> )? <DATATYPE> Name ( SpecializationClause )?
	DataTypeDefinition	:=	DataTypeDeclaration StructuredBody
	DataTypeDefinitionOrStub	:=	DataTypeDeclaration ( <SEMICOLON> | StructuredBody )
	StructuredBody	:=	<LBRACE> ( StructuredMember )* <RBRACE>
	StructuredMember	:=	( <DOCUMENTATION_COMMENT> )? StereotypeAnnotations ( <PUBLIC> )? PropertyDefinition

/* ASSOCIATIONS */

	AssociationDeclaration	:=	( <ABSTRACT> )? <ASSOC> Name ( SpecializationClause )?
	AssociationDefinition	:=	AssociationDeclaration StructuredBody
	AssociationDefinitionOrStub	:=	AssociationDeclaration ( <SEMICOLON> | StructuredBody )

/* ENUMERATIONS */

	EnumerationDeclaration	:=	<ENUM> Name ( SpecializationClause )?
	EnumerationDefinition	:=	EnumerationDeclaration EnumerationBody
	EnumerationDefinitionOrStub	:=	EnumerationDeclaration ( <SEMICOLON> | EnumerationBody )
	EnumerationBody	:=	<LBRACE> EnumerationLiteralName ( <COMMA> EnumerationLiteralName )* <RBRACE>
	EnumerationLiteralName	:=	( <DOCUMENTATION_COMMENT> )? Name

/* SIGNALS */

	SignalDeclaration	:=	( <ABSTRACT> )? <SIGNAL> Name ( SpecializationClause )?
	SignalDefinition	:=	SignalDeclaration StructuredBody
	SignalDefinitionOrStub	:=	SignalDeclaration ( <SEMICOLON> | StructuredBody )

/* ACTIVITIES */

	ActivityDeclaration	:=	<ACTIVITY> Name FormalParameters ( <COLON> TypePart )?
	ActivityDefinition	:=	ActivityDeclaration Block
	ActivityDefinitionOrStub	:=	ActivityDeclaration ( <SEMICOLON> | Block )
	FormalParameters	:=	<LPAREN> ( FormalParameterList )? <RPAREN>
	FormalParameterList	:=	FormalParameter ( <COMMA> FormalParameter )*
	FormalParameter	:=	( <DOCUMENTATION_COMMENT> )? StereotypeAnnotations ParameterDirection Name <COLON> TypePart
	ParameterDirection	:=	( <IN> | <OUT> | <INOUT> )

/* FEATURES */

	FeatureDefinitionOrStub	:=	( AttributeDefinition | OperationDefinitionOrStub )
	ActiveFeatureDefinitionOrStub	:=	( ReceptionDefinition | SignalReceptionDefinitionOrStub )

/* PROPERTIES */

	PropertyDefinition	:=	PropertyDeclaration <SEMICOLON>
	AttributeDefinition	:=	PropertyDeclaration ( AttributeInitializer )? <SEMICOLON>
	AttributeInitializer	:=	<ASSIGN> Expression
	PropertyDeclaration	:=	Name <COLON> ( <COMPOSE> )? TypePart
	TypePart	:=	TypeName ( Multiplicity )?
		|	<COLLECTION_NAME> ( <LT> TypeName <GT> )?
	TypeName	:=	( QualifiedName | <ANY> )
	Multiplicity	:=	<LBRACKET> ( MultiplicityRange )? <RBRACKET> ( <ORDERED> )? ( <NONUNIQUE> )?
	MultiplicityRange	:=	( <NATURAL_LITERAL> <DOUBLE_DOT> )? UnlimitedNaturalLiteral
	UnlimitedNaturalLiteral	:=	( <NATURAL_LITERAL> | <STAR> )

/* OPERATIONS */

	OperationDeclaration	:=	( <ABSTRACT> )? Name FormalParameters ( <COLON> TypePart )? ( RedefinitionClause )?
	OperationDefinitionOrStub	:=	OperationDeclaration ( <SEMICOLON> | Block )
	RedefinitionClause	:=	<REDEFINES> QualifiedNameList

/* RECEPTIONS */

	ReceptionDefinition	:=	<RECEIVE> QualifiedName <SEMICOLON>
	SignalReceptionDeclaration	:=	<RECEIVE> <SIGNAL> Name ( SpecializationClause )?
	SignalReceptionDefinitionOrStub	:=	SignalReceptionDeclaration ( <SEMICOLON> | StructuredBody )

DOCUMENT END
