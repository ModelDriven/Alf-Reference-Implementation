namespace Alf::Library::Collections::CollectionClasses::Impl;
private import Alf::Library::FunctionBehaviors::Collections::CollectionFunctions::*;
/**
The concrete implementation of the standard library template Map class.
*/
class Map<Key, Value> specializes CollectionClasses::Map<Key,Value> {

  private entries: Entry[0..*];

  @Create public Map (in entries: Entry[0..*]): Map<Key,Value> { 
    this.putAll(entries);
  }

  @Destroy public destroy () { 
  }

  private indexOf(in key: Key): Integer[0..1] {
    return this.entries.key->indexOf(key);
  }
  
  public entries (): Set<Entry> { 
    return new Set<Entry>(this.entries);
  }

  public clear () { 
    this.entries = null;
  }

  public excludesAll (in entries: Entry[0..*]): Boolean { 
    return this.entries->excludesAll(entries);
  }

  public get (in key: Key): Value[0..1] { 
    if ((i = this.indexOf(key))->isEmpty()) {
      return null;
    } else {
      return this.entries[i].value;
    }
  }

  public includesAll (in entries: Entry[0..*]): Boolean { 
    return this.entries->includesAll(entries);
  }

  public includesKey (in key: Key): Boolean { 
    return this.entries.key->includes(key);
  }

  public includesValue (in value: Value[0..1]): Boolean { 
    return this.entries.value->includes(value);
  }

  public isEmpty (): Boolean { 
    return this.entries->isEmpty();
  }

  public keys (): Set<Key> { 
    return new Set<Key>(this.entries.key);
  }

  public notEmpty (): Boolean { 
    return this.entries->notEmpty();
  }

  public put (in key: Key, in value: Value[0..1]): Value[0..1] { 
    if ((i = this.indexOf(key))->isEmpty()) {
      this.entries->add(new Entry(key,value));
      return null;
    } else {
      result = this.entries[i].value;
      this.entries[i].value = value;
      return result;
    }
  }

  public putAll (in entries: Entry[0..*]) { 
    entries->iterate e (this.put(e.key, e.value));
  }

  public remove (in key: Key): Value[0..1] { 
    if ((i = this.indexOf(key))->isEmpty()) {
      return null;
    } else {
      result = this.entries[i];
      this.entries->removeAt(i);
      return result;
    }
  }

  public removeAll (in keys: Key[0..*]) { 
    keys->iterate k (this.remove(k));
  }

  public size (): Integer { 
    this.entries->size();
  }

  public toSequence (): Entry[0..*] sequence { 
    return this.entries;
  }

  public values (): Bag<Value> { 
    return new Bag<Value>(this.entries.value);
  }
}

