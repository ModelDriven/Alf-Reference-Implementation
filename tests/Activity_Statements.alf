activity Statements() {

  /*@inline('C++')  // Native code
    data* = this;
    controller->initiate();
  */

  //@parallel 
  { 
    i = Expr1;
    last = Expr2;
    collection = Integer[]{};
    while (i <= last) { collection -> add(i++); }
  }
  
  ;
  
  let currentOffer : Offer = this.offers[1];
  DomainTypes.CurrencyAmount interest = this.principal * this.rate * period;
  let inactiveMembers : Member[] = members -> select member (!member.isActive);
  RealProperty[] realProperties = (RealProperty)assets;
  
  if (reading > threshold) {
     monitor.raiseAlarm(sensorId); 
  }
  
  //@determined @assured
  if (reading <= safeLimit) {
    condition = normal; }
  or if (reading > safeLimit && reading <= criticalLimit) {
    condition = alert; }
  or if (reading > criticalLimit) {
    condition = critical; }
  if (reading > threshold) {
     monitor.raiseAlarm(sensorId); 
  }
  
  if (reading <= safeLimit) {
    condition = normal; 
  }
  else if (reading <= criticalLimit) {
    condition = alert; 
  }
  else {
    condition = critical; 
  }
  
  if (reading <= safeLimit) {
    condition = normal; 
  }
  or if (reading > safeLimit && reading <= criticalLimit) {
    condition = alert; 
  }
  or if (reading > criticalLimit) {
    condition = critical; 
  }
  
  if (reading <= safeLimit) {
    condition = normal; }
  else if (reading > safeLimit && reading <= criticalLimit) {
    condition = alert; }
  or if (reading > criticalLimit && reading < errorLimit) {
    condition = critical; }
  else {
    condition = error; }
    
  switch (month) {
    case 1: case 3: case 5: case 7: case 8: case 10: case 12: {
      numDays = 31; 
    }
    case 4: case 6: case 9: case 11: {
      numDays = 30; 
    }
    case 2: {
      if ( ((year % 4 == 0) && !(year % 100 == 0))
           || (year % 400 == 0) ) {
        numDays = 29;
      } 
      else {
        numDays = 28;
      }
    }
    default: {
      WriteLine("Invalid month.");
      numDays = 0;
    }
  }
  
  while ((last = this.list->size()) > 0) {
    this.list[last].cleanUp();
    this.list->remove(last);
  }
  
  while (file.hasMore()) {
    nextRecord = file.readNext();
    if (!nextRecord->isEmpty()) {
      checksum = ComputeChecksum(checksum, nextRecord);
    }
  }
  
  do {
    line = file.readNext();
    WriteLine(line);
  } while (line != endMarker);
  
  do {
    reading = sensor.getNextReading();
    Record(reading);
  } while (!reading.isFinal());
  
  for (member in memberList) {
    names->add(member.name);
    addresses->add(member.address);
  }
  
  for (sensor in sensors while (reading = sensor.reading())->notEmpty()) {
    if (reading > noiseLimit) {
      readings->add(reading);
    }
  }
  
  for (i in 1..recordCount) {
    processRecord(i);
  }
  
  //@parallel 
  for (outgoingEdge in this.outgoingEdges) {
    outgoingEdge.sendOffer(tokens);
  }
  
  //@parallel(SnEven,SnOdd)
  for (lower in SLower, upper in SUpper, root in V) {
    //@parallel 
    {
      SnEven -> add(lower+upper);
      SnOdd  -> add((lower-upper)*root);
    }
  }
  
  return item;
  return list[index];
  return x * factorial(x-1);
  
  accept (sig: SignalNewArrival, SignalTermination);
  
  accept (arrival: SignalNewArrival) {
    WriteLine(arrival.name);
    terminate = false;
  } or accept (SignalTermination) {
    terminate = true;
  }
  
  accept (SignalNewArrival);
  
  accept (arrival: SignalNewArrival);
  WriteLine(arrival.name);
  
  accept (sig: SignalNewArrival, SignalTermination);
  if (sign instanceof SignalNewArrival) {
    WriteLine(((SignalNewArrival)sig).name);
    terminate = false;
  } else {
    terminate = true;
  }
  
  accept (arrival: SignalNewArrival) {
    WriteLine(arrival.name);
    terminate = false;
  } or accept (SignalTermination) {
    terminate = true;
  }
  
  classify principal from * to Administrator;
  classify principal from Administrator;
  classify monitor from InActiveMonitor to ActiveMonitor;
  classify this 
    from Pending, Overdue 
    to Resolved, InProcess;

}
